<!doctype html>
<html class="theme-next   use-motion ">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.4.5.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="lhy的博客" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.2" />






<meta name="description" content="Science technology and culture">
<meta property="og:type" content="website">
<meta property="og:title" content="lhy的博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="lhy的博客">
<meta property="og:description" content="Science technology and culture">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="lhy的博客">
<meta name="twitter:description" content="Science technology and culture">



<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: 'Mist',
    sidebar: 'post',
    motion: true
  };
</script>

  <title> lhy的博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  






  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">lhy的博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">Science technology and culture</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-user fa-fw"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-th fa-fw"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content">
          
  <section id="posts" class="posts-expand">

    

    
    

    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/30/面试题-前端/" itemprop="url">
                  面试题-前端
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2016-06-30T22:48:16+08:00" content="2016-06-30">
              2016-06-30
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Technology/" itemprop="url" rel="index">
                    <span itemprop="name">Technology</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h1 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h1><p>1.<a href="https://github.com/markyun/My-blog/tree/master/Front-end-Developer-Questions/Questions-and-Answers" target="_blank" rel="external">前端开发面试题</a></p>
<p>2.<a href="https://mp.weixin.qq.com/s?__biz=MzAwNjI5MTYyMw==&amp;mid=401123752&amp;idx=1&amp;sn=06f51d5b97eff32453a4d4f1f470fc86&amp;scene=1&amp;srcid=0630crXOLAN1aUD2Z9Z7Ts9F&amp;key=77421cf58af4a65365b167293befc93d92f7ffd02d23ffd09759ce0eace874a1aab092e8e8aa9f4b3e2fe57208e314a6&amp;ascene=0&amp;uin=MjE2MTU5NjQyMA%3D%3D&amp;devicetype=iMac+MacBookPro8%2C1+OSX+OSX+10.11.5+build" target="_blank" rel="external">2015 前端[JS]工程师必知必会</a>   </p>
<p>3.<a href="https://mp.weixin.qq.com/s?__biz=MzAwNjI5MTYyMw==&amp;mid=401105848&amp;idx=1&amp;sn=65e1ced1f8e3e305ff2c40aa8a08f24a&amp;scene=1&amp;srcid=0630DDYWwLxbaDZcLLYriRgE&amp;key=77421cf58af4a65315c8bf65e2cecb44ebe452f876031a5771c9a887852b86521ffda7d4a0a1a2497fc85f063073b431&amp;ascene=0&amp;uin=MjE2MTU5NjQyMA%3D%3D&amp;devicetype=iMac+MacBookPro8%2C1+OSX+OSX+10.11.5+build" target="_blank" rel="external">2015年十大热点javascript笔试题你都会么</a>   </p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/23/javascript小结3/" itemprop="url">
                  javascript小结3
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2016-06-23T18:57:05+08:00" content="2016-06-23">
              2016-06-23
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Technology/" itemprop="url" rel="index">
                    <span itemprop="name">Technology</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <h1 id="php"><a href="#php" class="headerlink" title="php"></a>php</h1><p>P120</p>
<p>学习一门新语言:语法,函数,库</p>
<p>算法独立出语言</p>
<h1 id="typescipt"><a href="#typescipt" class="headerlink" title="typescipt"></a>typescipt</h1><h1 id="jquery"><a href="#jquery" class="headerlink" title="jquery"></a>jquery</h1><p>P153</p>
<h2 id="jquery源码分析"><a href="#jquery源码分析" class="headerlink" title="jquery源码分析"></a>jquery源码分析</h2><p>P161<br>笔记在练习代码上</p>
<h1 id="angular"><a href="#angular" class="headerlink" title="angular"></a>angular</h1><h1 id="nodejs"><a href="#nodejs" class="headerlink" title="nodejs"></a>nodejs</h1><h1 id="express"><a href="#express" class="headerlink" title="express"></a>express</h1><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><h3 id="《javascript权威指南》"><a href="#《javascript权威指南》" class="headerlink" title="《javascript权威指南》"></a>《javascript权威指南》</h3>
            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/23/javascript小结2/" itemprop="url">
                  javascript小结2
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2016-06-23T18:55:27+08:00" content="2016-06-23">
              2016-06-23
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Technology/" itemprop="url" rel="index">
                    <span itemprop="name">Technology</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <h1 id="javascript"><a href="#javascript" class="headerlink" title="javascript"></a>javascript</h1><script type="”text/javascript”">

</script>

<h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><p>下面是前端Browser的DOM,还不是后端如nodejs的DOM</p>
<p>ECMScript:解释器,翻译</p>
<p>DOM: Document Object Model. 就是document。 文档（HTML/网页）对象模型，把网页/文档变成JS可以操作的对象。DOM给了JS操作页面元素的能力。也就是<code>document</code></p>
<p>BOM: Browser Object Model   兼容性问题的来源。给了JS操纵浏览器的功能（收藏夹，打印机，location之类的），就是<code>window</code>。</p>
<h2 id="JS变量类型"><a href="#JS变量类型" class="headerlink" title="JS变量类型"></a>JS变量类型</h2><p>注:typeof 返回的是字符串,如’number’,但有时返回的是string,true,不加引号’’</p>
<h3 id="5种原始类型"><a href="#5种原始类型" class="headerlink" title="5种原始类型:"></a>5种原始类型:</h3><p>string,number,boolean,undefined,null</p>
<h4 id="string和number"><a href="#string和number" class="headerlink" title="string和number"></a>string和number</h4><p>它们之间可以用 ‘+’进行拼接</p>
<p>String字符串类型是由双引号” “或单引号’ ‘声明的。</p>
<p>还有一些字符串的字面量如’hello’</p>
<p>常见的错误写法:</p>
<p>alert(hello);</p>
<p>console.log(parseInt(12px));</p>
<h4 id="undefined和null"><a href="#undefined和null" class="headerlink" title="undefined和null"></a>undefined和null</h4><p>如果对类型typeof,5种基本类型中的null或者引用类型会返回Object. JS把null认为是对象的占位符</p>
<p>alert(null == undefined);  //输出 “true”<br>alert(null === undefined); //输出false</p>
<p>尽管这两个值相等，但它们的含义不同。undefined 是声明了变量但未对其初始化时赋予该变量的值，null 则用于表示尚未存在的对象。如果函数或方法要返回的是对象，那么找不到该对象时，返回的通常是 null。</p>
<p>console.log(typeof(undefined));//undefined</p>
<p>console.log(typeof(null));//object</p>
<p>注意null不要写成Null或NULL,会报错</p>
<h3 id="复合类型（对象（包括数组，HTML标签，日期））"><a href="#复合类型（对象（包括数组，HTML标签，日期））" class="headerlink" title="复合类型（对象（包括数组，HTML标签，日期））"></a>复合类型（对象（包括数组，HTML标签，日期））</h3><p>引用类型array,function,arguments?</p>
<p>注:object不是JS类型,只是typeof的返回值</p>
<p>var arr = new Array(1,2,3);</p>
<p>  console.log(typeof(arr));//object</p>
<p>function show(){</p>
<p>  console.log(typeof(arguments));//object</p>
<p>}</p>
<p>show();</p>
<p>console.log(typeof(show));//function</p>
<p>注:变量（var）类型是由其里面存储的东西决定</p>
<h3 id="boolean类型"><a href="#boolean类型" class="headerlink" title="boolean类型"></a>boolean类型</h3><p>true为真，false为假</p>
<p>非0为真，0为假</p>
<p>非空字符串为真(‘ ‘空格也是真的)，空字符串为假的(‘’)</p>
<p>非空对象是真的，空对象NaN是假的</p>
<p>undefined是假的</p>
<p>真的：true，非0数字，非空字符串，非空对象</p>
<p>假的：false，数字0，空字符串，空对象，undefined</p>
<h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><p>可以把数组放入JSON，也可以把JSON放入数组</p>
<p>JSON中可以存储多种类型的变量</p>
<p>for in</p>
<p>一般和JSON或其他对象混合使用</p>
<h3 id="函数传参arguments"><a href="#函数传参arguments" class="headerlink" title="函数传参arguments"></a>函数传参arguments</h3><p>arguments是集合类型,不是数组类型。类数组。具有length等属性。</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>var arr = [1,2,3,4];</p>
<p>var arr = new Array(1,2,3,4);</p>
<p>数组属性length</p>
<p>数组中应该只存一种类型的变量</p>
<h4 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h4><p>涉及到算法的操作大多数都是:<code>增删查改,排序</code>等。</p>
<p>把函数作为参数,方便用户自定义函数。底层人员负责实现底层函数,用户只需要实现参数(函数)就行了。</p>
<p><code>排序</code></p>
<p>sort([比较函数])</p>
<p><code>转换</code></p>
<p>concat(数组2)  //连接2个数组</p>
<p>join(分隔符)</p>
<p>   用分隔符,组合数组元素,生成字符串</p>
<p>   字符串split</p>
<p><code>插入</code></p>
<p>splice(开始,长度)</p>
<p><code>删除</code></p>
<p>splice(开始,0,元素)</p>
<p><code>替换</code></p>
<p><code>concat()</code>方法用于连接两个或多个数组</p>
<p>//该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。</p>
<p>//连接元素</p>
<p>var a = new Array(2);</p>
<p>a[0] = ‘a’;</p>
<p>a[1] = ‘b’;</p>
<p>console.log(a.concat(‘c’)); //[‘a’,’b’,’c’]</p>
<p>//console.log(a.concat(c));//这样会报错: c is not defined   这样写就会把c当成变量</p>
<p>//连接数组,增加的其实是数组元素,而非数组</p>
<p>var a = new Array(2);</p>
<p>a[0] = ‘a’;</p>
<p>a[1] = ‘b’;</p>
<p>var a1 = new Array(2);</p>
<p>a1[0] = ‘a1’;</p>
<p>a1[1] = ‘b1’;</p>
<p>var a2 = new Array(2);</p>
<p>a2[0] = ‘a2’;</p>
<p>a2[1] = ‘b2’;</p>
<p>console.log(a.concat(a1,a2));//[‘a’,’b’,’a1’,’b1’,’a2,’b2’]</p>
<p><code>join()</code> 方法用于把数组中的所有元素放入一个字符串。元素是通过指定的分隔符进行分隔的。<br>//参数指定要使用的分隔符。如果省略该参数，则使用<code>逗号</code>作为分隔符。</p>
<p>var a = new Array(3);</p>
<p>a[0] = ‘a’;</p>
<p>a[1] = ‘b’;</p>
<p>a[2] = ‘c’;</p>
<p>console.log(a.join());//a,b,c</p>
<p>//console.log(a.join(+));//报错</p>
<p>console.log(a.join(‘+’));//a+b+c</p>
<p><code>pop()</code>方法将删除数组的最后一个元素，把数组长度减 1，并且返回它删除的元素的值。<br> 如果数组已经为空，则 pop() 不改变数组，并返回 undefined 值。</p>
<p>var a = new Array(3);</p>
<p>a[0] = ‘a’;</p>
<p>a[1] = ‘b’;</p>
<p>a[2] = ‘c’;</p>
<p>console.log(a.pop());//c</p>
<p>console.log(a);//[‘a’,’b’]</p>
<p>console.log(a.pop());//b</p>
<p>console.log(a.pop());//a</p>
<p>console.log(a.pop());//undefined</p>
<p><code>push()</code>方法可把它的参数顺序添加到数组的尾部。它直接修改数组,而不是创建一个新的数组。</p>
<p>push() 方法和 pop() 方法使用数组提供的先进后出 栈的功能。</p>
<p>此方法会直接修改原数组,不会创建副本</p>
<p>返回数组的新长度</p>
<p>要想数组的开头添加一个或多个元素，请使用 unshift() 方法。</p>
<p>var a = new Array(3);</p>
<p>a[0] = ‘a’;</p>
<p>a[1] = ‘b’;</p>
<p>a[2] = ‘c’;</p>
<p>console.log(a.push(‘d’));//4</p>
<p>console.log(a); //[‘a’,’b’,’c’,’d’]</p>
<p><code>reverse()</code> 方法用于颠倒数组中元素的顺序。</p>
<p>var a = new Array(3);</p>
<p>a[0] = ‘a’;</p>
<p>a[1] = ‘b’;</p>
<p>a[2] = ‘c’;</p>
<p>console.log(a.reverse());//[‘c’,’b’,’a’]</p>
<p><code>shift()</code>方法用于把数组的<code>第一个元素从其中删除</code>，并返回第一个元素的值。<br>如果数组是空的，那么 shift() 方法将不进行任何操作，返回 undefined 值。<br>请注意，该方法不创建新数组，而是直接修改原数组</p>
<p>var a = new Array(3);</p>
<p>a[0] = ‘a’;</p>
<p>a[1] = ‘b’;</p>
<p>a[2] = ‘c’;</p>
<p>console.log(a.shift());//a</p>
<p>console.log(a);//[‘b’,’c’]</p>
<p><code>slice()</code> 方法</p>
<p>//arrayObject.slice(start,end)</p>
<p>//返回一个新的数组，包含从 start 到 end （不包括该元素）的数组中的元素。</p>
<p>//该方法并不会修改数组，而是返回一个子数组。如果想删除数组中的一段元素，应该使用方法 Array.splice()。</p>
<p>//可使用负值从数组的尾部选取元素。</p>
<p>//如果 end 未被规定，那么 slice() 方法会选取从 start 到数组结尾的所有元素。</p>
<p>var a = new Array(3);</p>
<p>a[0] = ‘a’;</p>
<p>a[1] = ‘b’;</p>
<p>a[2] = ‘c’;</p>
<p>console.log(a.slice(1));//[‘b’,’c’]</p>
<p>console.log(a);//[‘a’,’b’,’c’]</p>
<p>console.log(a.slice(1,2));//[‘b’]</p>
<p>console.log(a.slice(-1));//[‘c’]</p>
<p>console.log(a.slice(-1,-2));//[]   //注:必须是正向</p>
<p>console.log(a.slice(-2,-1));//[‘b’]</p>
<p><code>sort()方法</code></p>
<p><code>splice()</code> 方法与 slice() 方法的作用是不同的，splice() 方法会直接对数组进行修改。</p>
<p>//该方法会改变原始数组。</p>
<p>//返回包含被删除项目的新数组</p>
<p>//arrayObject.splice(index,howmany,item1,…..,itemX)</p>
<p>//index:规定添加/删除项目的位置，使用负数可从数组结尾处规定位置        删除    位置,数目</p>
<p>//howmany:要删除的项目数量                                        删除</p>
<p>//itemX:向数组添加的新项目                                       添加    数目</p>
<p>//splice() 方法可删除从 index 处开始的零个或多个元素，并且用参数列表中声明的一个或多个值来替换那些被删除的元素。</p>
<p>//如果从 arrayObject 中删除了元素，则返回的是含有被删除的元素的数组</p>
<p>var arr = new Array(6)</p>
<p>arr[0] = “10”</p>
<p>arr[1] = “5”</p>
<p>arr[2] = “40”</p>
<p>arr[3] = “25”</p>
<p>arr[4] = “1000”</p>
<p>arr[5] = “1”</p>
<p>console.log(arr.splice(0,2,’a’));//[‘10’,’5’]</p>
<p>console.log(arr);//[‘a’,’40’,’25’,’1000’,’1’]</p>
<p><code>toSource()</code> 方法</p>
<p><code>toString()</code>方法</p>
<p><code>toLocaleString()</code>方法</p>
<p><code>unshift()</code> 方法</p>
<p><code>valueOf()</code> 方法</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><h4 id="字面值常量"><a href="#字面值常量" class="headerlink" title="字面值常量"></a>字面值常量</h4><h4 id="new-对象"><a href="#new-对象" class="headerlink" title="new 对象"></a>new 对象</h4><p>由于JS中一切皆是对象。</p>
<h3 id="赋值传递"><a href="#赋值传递" class="headerlink" title="赋值传递"></a>赋值传递</h3><p>引用：对象、数组、函数</p>
<p>复制：数字、布尔</p>
<p>number类型:</p>
<p>var a1=b1=5;</p>
<p>a1=6;</p>
<p>console.log(a1);</p>
<p>console.log(b1);</p>
<p>//6,5</p>
<p>//数组类型</p>
<p>var a1 = [1];</p>
<p>var b1 = a1; //引用传递</p>
<p>//上面等价于  var b2 = a2 = [1];</p>
<p>b1[0]++;</p>
<p>console.log(a1);</p>
<p>console.log(b1);</p>
<p>//2,2</p>
<p>//下面情况就变了</p>
<p>var b2=a2=[1];</p>
<p>b2 = [2];//赋值在后面。</p>
<p>console.log(a2);</p>
<p>console.log(b2);</p>
<p>//后面没有 a2 = b2 的引用传递过程,所以a2的值就没有改变</p>
<p>//1,2</p>
<p>这个在nodejs的 exports = module.exports = xxx;经常会用到。</p>
<p>//赋值是从右往左的</p>
<p>另一个使用场景在函数的传参中。</p>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><h3 id="显示转换"><a href="#显示转换" class="headerlink" title="显示转换"></a>显示转换</h3><p>parseInt()字符串转数字（从字符串中提取数字，从左到右直到不是数字的）</p>
<p>parseInt(12px); = 12;</p>
<p>parseInt(‘abc’);   // NaN  not a number    提取不到数字</p>
<p>parseInt(‘abc12’)  // NaN  从左到右</p>
<p>parseFloat()  //把字符串转换为小数</p>
<h4 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h4><p>NaN和任何类型运算，都是NaN</p>
<p>不能拿2个NaN比较:</p>
<p>isNaN()   a=’abc’  isNaN(a)  返回true</p>
<h3 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h3><h4 id="和-运算符"><a href="#和-运算符" class="headerlink" title="==和===运算符"></a>==和===运算符</h4><p>a=’12’</p>
<p>b=12</p>
<p>a==b    true   ==会把a,b转化为一样的类型再比较</p>
<p>a===b      false    ===不转换就比较</p>
<p>== ，!=转换数据类型再比较</p>
<p>===，!== 不转换数据类型直接比较</p>
<h4 id="其他运算符"><a href="#其他运算符" class="headerlink" title="其他运算符"></a>其他运算符</h4><p>-减法   *乘法   除法  都会转换,<br>但加法 + 不会转换<br>因为加法能够   字符串连接   数字相加<br>但减法  只能做 数字相减</p>
<p>例子:</p>
<p>var a = 1+’1’;</p>
<p>console.log(a,typeof(a)); // 11 ,string</p>
<p>var b = 2-‘1’;</p>
<p>console.log(b,typeof(b)); // 11 ,”number”</p>
<p>console.log(typeof(c)); //undefined</p>
<p>console.log(null==undefined);// true  注意null不要写成Null或NULL,会报错<br>}</p>
<p>取模运算符 %</p>
<h2 id="变量作用域与闭包"><a href="#变量作用域与闭包" class="headerlink" title="变量作用域与闭包"></a>变量作用域与闭包</h2><p>变量起作用的范围</p>
<p>  局部变量：定义在一个函数里，只能在一个函数中使用</p>
<p>  全局变量：不定义在任何一个函数中他，可以在任何地方使用。</p>
<p>JS中没有块级作用域的说法。比如for(){}  if(){}   等,只有全局作用域和局部作用域(函数作用域)</p>
<p>注:var a;   var 即是定义，不是声明。这一点和C语言不一样。</p>
<p>（3）闭包    局部变量在闭包里也可以使用</p>
<p>function a(){</p>
<p>var a=12;</p>
<p>function b(){</p>
<p>alert(a);</p>
<p>}</p>
<p>}</p>
<p>子函数可以使用父函数内的局部变量</p>
<p>//闭包特点</p>
<p>//函数嵌套函数,内部函数可以引用外部函数的参数和变量,参数和变量不会被垃圾回收机制所收回</p>
<p>function aaa(){</p>
<pre><code>var a = 5;

function bbb(){

    alert(a);

}

return bbb;
</code></pre><p>}</p>
<p>var c = aaa();//在外部调用aaa(),在这个地方aaa()已经执行完毕</p>
<p>c();//c代表bbb()这个函数,c执行,变量并没有被收回,可以弹出a=5</p>
<p><code>未完待续</code></p>
<p><a href="http://www.cnblogs.com/rainman/archive/2009/04/28/1445687.html" target="_blank" rel="external">深入理解JavaScript的变量作用域</a>    </p>
<p>仔细观察下面的代码，你会发现<code>变量i、j、k作用域是相同的，他们在整个rain函数体内都是全局的</code>。</p>
<p>也就是说<code>JS只有全局作用域和函数作用域,没有块作用域的说法</code>。</p>
<p>function rainman(){</p>
<pre><code>    // rainman函数体内存在三个局部变量 i j k

    var i = 0;

    if ( 1 ) {

        var j = 0;

        for(var k = 0; k &lt; 3; k++) {

            alert( k );    //分别弹出 0 1 2
        }

        alert( k );        //弹出3

        //`for循环变量k,这个在DOM事件处理中经常会用到`

    }

    alert( j );            //弹出0

    //`上面的if{}块没有阻碍j`

}
</code></pre><p><a href="https://github.com/alsotang/node-lessons/tree/master/lesson11" target="_blank" rel="external">作用域与闭包：this，var，(function () {})</a><br><code>如果忘记var，那么变量就被声明为全局变量了</code>。</p>
<p>还有就是JS不像C语言,声明,定义得来2次,JS就一次。并且<code>带不带var都可以</code>,只不过不带var是全局的,带var可能是全局,也可能是局部的。</p>
<p>function foo() {</p>
<p>  value = “hello”;</p>
<p>}</p>
<p>foo();</p>
<p>console.log(value); // 输出hello</p>
<p>console.log(global.value) // 输出hello</p>
<h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><p>条件?语句1:语句2</p>
<h3 id="break"><a href="#break" class="headerlink" title="break"></a>break</h3><h3 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h3><h2 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h2><p>匈牙利命名法</p>
<p>类型前缀，首字母大写</p>
<h2 id="函数function"><a href="#函数function" class="headerlink" title="函数function"></a>函数function</h2><p>function没有返回值时返回的是undefined</p>
<p>function show(){</p>
<p>}</p>
<p>alert(show());//undefined</p>
<p>函数常常与闭包,this连在一起。见另外的地方这2个方面的内容。</p>
<h3 id="匿名函数自执行"><a href="#匿名函数自执行" class="headerlink" title="匿名函数自执行"></a>匿名函数自执行</h3><p>//注意可直接在函数声明后面加上括号就表示创建完成后立即进行函数调用</p>
<p>var i=function (a,b){ //由于后面有(1,2), i表示返回值而非创建的函数。因为()比= 有更高的优先级。这样的代码可能并不常用，但当用户想在很长的代码段中进行模块化设计或者想避免命名冲突，这是一个不错的解决办法</p>
<pre><code>return a+b;
</code></pre><p>}(1,2);</p>
<p>alert(i);</p>
<p>//尽管下面两种创建函数的方法是等价的：</p>
<p>function funcName(){</p>
<pre><code>//函数体
</code></pre><p>}</p>
<p>//等价于</p>
<p>var funcName=function(){</p>
<pre><code>//函数体
</code></pre><p>}</p>
<p>//但前面一种方式创建的是有名函数，而后面是创建了一个无名函数，只是让一个变量指向了这个无名函数。</p>
<p>//在使用上仅有一点区别，就是：对于有名函数，它可以出现在调用之后再定义；而对于无名函数，它必须是在调用之前就已经定义。</p>
<p>//下面这段语句将产生func未定义的错误</p>
<p>func();</p>
<p>var func=function(){</p>
<pre><code>alert(1)
</code></pre><p>}</p>
<p>//下面则能够正确执行</p>
<p>func();</p>
<p>function func(){</p>
<pre><code>alert(1)
</code></pre><p>}</p>
<p>//由此可见，尽管JavaScript是一门解释型的语言，但它会在函数调用时，检查整个代码中是否存在相应的函数定义，这个函数名只有是通过function funcName()形式定义的才会有效，而不能是匿名函数。</p>
<p><a href="http://www.cnblogs.com/TomXu/archive/2011/12/31/2289423.html" target="_blank" rel="external">深入理解JavaScript系列（4）：立即调用的函数表达式</a>   </p>
<p>function()</p>
<p>{</p>
<p>  console.log(3);</p>
<p>}();  //报错</p>
<p>function foo()//给函数加个名字照样报错</p>
<p>{</p>
<p>  console.log(3);</p>
<p>}();</p>
<p>//解决:加()</p>
<p>(function()</p>
<p>{<br>  console.log(2);</p>
<p>}());  // 2</p>
<p>(function()</p>
<p>{</p>
<p>  console.log(2);</p>
<p>})()   // 2</p>
<h3 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h3><p><code>arguments和this</code></p>
<p>var later1 = function(a,b)</p>
<p>{</p>
<p>  console.log(arguments); //{ ‘0’: 1 }</p>
<p>}</p>
<p>function test(a,b)</p>
<p>{</p>
<p>  var self = this;</p>
<p>  console.log(arguments);//{ ‘0’: 1, ‘1’: 2 }  //集合下标是字符串?</p>
<p>  later1(a);</p>
<p>}</p>
<p>test(1,2);</p>
<p>//对比:</p>
<p>function test(a,b)</p>
<p>{</p>
<p>  var self = this;</p>
<p>  var args = arguments;</p>
<p>  console.log(arguments);//{ ‘0’: 1, ‘1’: 2 }</p>
<p>  // var test1 = function(a)</p>
<p>  // {</p>
<p>  //   console.log(arguments);//{ ‘0’: 1 }</p>
<p>  //   console.log(args);//{ ‘0’: 1, ‘1’: 2 }</p>
<p>  // }</p>
<p>  // test1(a);</p>
<p>  //或者像下面这样写</p>
<p>  (function(a){</p>
<pre><code>console.log(arguments);//{ &apos;0&apos;: 1 }

console.log(args);//{ &apos;0&apos;: 1, &apos;1&apos;: 2 }
</code></pre><p>  })(a);</p>
<p>}</p>
<p>test(1,2);</p>
<p>//结论:arguments和this一样。都存在作用域链的问题。</p>
<h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h2><p>P54</p>
<h3 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h3><p>页面中用class，JS中用className</p>
<h2 id="javascript面向对象"><a href="#javascript面向对象" class="headerlink" title="javascript面向对象"></a>javascript面向对象</h2><p>P64</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>抽象:抽出核心问题</p>
<p>封装:不考虑内部实现,只考虑功能使用</p>
<p>继承:子类继承父类原有信息，子类再自己写一些东西。</p>
<p>   多重继承:有多个父亲。</p>
<p>   多态：父类和子类有相同的操作，但操作之间又不一样。</p>
<h3 id="对象的组成"><a href="#对象的组成" class="headerlink" title="对象的组成"></a>对象的组成</h3><p>方法——函数:过程,动态的</p>
<p>属性——变量:状态,静态的</p>
<h3 id="例子代码"><a href="#例子代码" class="headerlink" title="例子代码"></a>例子代码</h3><p>使用构造函数来存储属性</p>
<p>使用原型来构建方法</p>
<p>使用原型来继承</p>
<p>function Person(name,sex)//父类的构造函数,存储属性</p>
<p>{//一般来说构造函数名就是类名,首字母大写</p>
<p>  this.name = name;</p>
<p>  this.sex = sex;</p>
<p>}</p>
<p>//定义方法</p>
<p>Person.prototype.showName = function()</p>
<p>{</p>
<p>  console.log(this.name);</p>
<p>}</p>
<p>Person.prototype.showSex = function()</p>
<p>{</p>
<p>  console.log(this.sex);</p>
<p>}</p>
<p>//创建类的实例</p>
<p>//JS中一切皆是对象。String,Array对象都可以用new的方式创建实例。这些自定义的对象也采用了这种形式，</p>
<p>var p1 = new Person(‘liu’,’man’);//写为’liu’,’man’是字面值常量,写为liu,man则是未定义的变量。会报错。</p>
<p>p1.showName();</p>
<p>p1.showSex();</p>
<p>//下面开始定义子类并继承</p>
<p>//属性的继承是通过在子类的构造函数中调用父类的构造函数实现</p>
<p>function Worker(name,sex,job)</p>
<p>{</p>
<p>  //一般的调用形式是:对象.方法。但call,apply的调用形式反过来了:方法.对象.参数。因为此时的方法并非这个对象上的。只是在这个对象上调用</p>
<p>  Person.call(this,name,sex);</p>
<p>  //子类新的属性</p>
<p>  this.job = job;</p>
<p>}</p>
<p>//通过原型来继承父级的方法</p>
<p>//赋值的方法,引用传递?</p>
<p>Worker.prototype = Person.prototype;</p>
<p>//实例化的方式,但属性这一块与上面有些重复</p>
<p>//var Worker = new Person();//错误</p>
<p>Worker.prototype = new Person();//不过这里不像真的实例化那样带参数</p>
<p>//子类自定义的方法</p>
<p>//Worker.prototype.showJob = function(job)//错误,参数传递在构造函数中进行,方法只用来执行功能</p>
<p>Worker.prototype.showJob = function()</p>
<p>{</p>
<p>  console.log(this.job);</p>
<p>}<br>var w1 = new Worker(‘liu’,’man’,’worker’);</p>
<p>//w1.showJob(‘worker’);</p>
<p>w1.showJob();//worker</p>
<p>JS采用的是原型继承。给对象添加属性和方法就比较简单。在给已有的对象(如Array)添加属性或方法的时候可能会冲突。所以自己添加时往往需要一个空白的对象。object就是一个空白的对象。</p>
<h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>JS中的this主要有4种使用场景。可以分别在browser和nodejs上测试，</p>
<p>函数嵌套</p>
<p>变量的作用域</p>
<p>这属于 JavaScript 的设计缺陷，正确的设计方式是内部函数的 this 应该绑定到其外层函数对应的对象上，为了规避这一设计缺陷，常常变量替代的方法，约定俗成，该变量一般被命名为 that/self。</p>
<p><a href="https://segmentfault.com/a/1190000002640298" target="_blank" rel="external">JavaScript中的this陷阱的最全收集–没有之一</a></p>
<p>//在浏览器中有3种情形,在nodejs中有5种情形</p>
<p>//浏览器:</p>
<p>//a. this和window</p>
<p>//b. 全局范围内,加var声明变量,给this/window添加属性</p>
<p>//c. 不加var声明变量,给this/window添加属性</p>
<p>// 加var必须在全局范围内(不能在函数,json等内)才属于全局范围内的this,不加var,在任何地方都是全局范围内的this的属性(不加var,就成全局的了)。全局范围的this就等于window</p>
<p>//nodejs</p>
<p>//a. REPL中,最高级的是global, global===this</p>
<p>//b. 全局范围内执行一个js脚本.this是一个为{}的最高级空间,this和global不等价</p>
<p>//c. 全局范围内执行一个js脚本. 用var声明一个变量不会像浏览器中那样添加给this作为属性</p>
<p>//d. 不是执行一个js脚本,而是直接执行代码,用var声明一个变量和浏览器中一样样添加给this作为属性(神坑)</p>
<p>//e. 执行一个js脚本文件,声明变量的时候没用var或let(es6),变量会添加给global对象当属性,而不会添加给this对象</p>
<p>//f. 不是执行一个js脚本,而是直接执行代码,声明变量的时候没用var或let(es6),变量会同时添加给global和this对象当属性</p>
<p>//八种情况总结</p>
<p>//在浏览器里面this是老大，它等价于window对象，如果你声明一些全局变量(不管在任何地方)，这些变量都会作为this的属性。</p>
<p>//在node里面，有两种执行JavaScript代码的方式，</p>
<p>//一种是直接执行写好的JavaScript文件，</p>
<p>//另外一种是直接在里面执行一行行代码。</p>
<p>//对于直接运行一行行JavaScript代码的方式，global才是老大，this和它是等价的。在这种情况下，和浏览器比较相似，也就是声明一些全局变量会自动添加给老大global，顺带也会添加给this。<br>//但是在node里面直接脚本文件就不一样了，你声明的全局变量不会自动添加到this，但是会添加到global对象。</p>
<p>//所以相同点是，在全局范围内，全局变量终究是属于老大(global/window  在浏览器中this==window,在node中直接执行代码,global===this,执行js文件,global最大)的。<br>//变量和属性。 变量是对象的属性。  隐含对象。</p>
<h4 id="function调用的4种方式"><a href="#function调用的4种方式" class="headerlink" title="function调用的4种方式"></a>function调用的4种方式</h4><p>js中有四种调用模式—方法、函数、构造器以及apply调用模式，它们在初始化this时候是不一样的</p>
<p>(1)方法模式 简单的说就是使用点号表达式或是下标表达式(下标里是字符串?)来调用(JS中没有箭头运算符) 这里定然是有对象的 这种情况下 this的绑定发生在调用的时候 绑的自然是调它的那个对象了</p>
<p>(2)函数模式 这个就更简单了  函数名加调用运算符（’()’）  不过要小心  这个this绑的可是全局对象  不管你写哪了。可以理解成  你不给我指明了,我就自己给它加个全局对象。</p>
<p>有了上面变量和作用域的基础,我们来看看<code>嵌套函数下的this</code>.</p>
<p>例子:</p>
<p>var name = 3;</p>
<p>var obj = { //JON对象</p>
<p>   name:1,</p>
<p>   showName:function(){</p>
<pre><code>console.log(this.name);
</code></pre><p>   }</p>
<p>}</p>
<p>obj.double = function()</p>
<p>{</p>
<p>  var name = 2;</p>
<p>  var dd = function()</p>
<p>  {</p>
<pre><code>console.log(this.name);//3

console.log(obj.name);//1

//看name属于谁,当看它离哪个作用域最近,且JS只有2个作用域:全局和函数。要不然都会归结到全局(顶层作用域)上去,这也不合理

//还有这属于 JavaScript 的设计缺陷，正确的设计方式是内部函数的 this 应该绑定到其外层函数对应的对象上，为了规避这一设计缺陷，常常变量替代的方法，约定俗成，该变量一般被命名为 that/self。
</code></pre><p>  }</p>
<p>  dd();</p>
<p>}</p>
<p>obj.double();</p>
<p>上面的this.name绑定到全局name中去了。是3.</p>
<p>现在的解决办法:</p>
<p>obj.name = function(){</p>
<p>  var name = 2;</p>
<p>  var that = this;</p>
<p>  var dd = function()</p>
<p>  {</p>
<pre><code>console.log(this.name);//1

console.log(obj.name);//1
</code></pre><p>  }</p>
<p>}</p>
<p>(3)构造器调用模式  一句话就是用new来调用的  new的时候this就绑定到新对象上了  比较好理解</p>
<p>(4)apply调用模式  apply是函数的一个方法吧 你想把谁绑定到this 就直接把它作为第一个参数传给apply就好了</p>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>字符串的处理是每种语言的一个重点</p>
<p>p145</p>
<p>P152 问题</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><h3 id="《javascript权威指南》"><a href="#《javascript权威指南》" class="headerlink" title="《javascript权威指南》"></a>《javascript权威指南》</h3>
            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/21/node环境搭建/" itemprop="url">
                  node环境搭建
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2016-06-21T12:33:01+08:00" content="2016-06-21">
              2016-06-21
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Technology/" itemprop="url" rel="index">
                    <span itemprop="name">Technology</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>以前都是把学习记录写在word上。按照时间线的记录方式不利于回顾。现在按照主题线写在博客上。现在把以前学习node的一些在这里总结一下。具体的项目分析见另外一篇文章《nodeclub源码分析》。</p>
<h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><p>MACOS + webstorm</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="官方安装node"><a href="#官方安装node" class="headerlink" title="官方安装node"></a>官方安装node</h2><p>可以在<a href="https://nodejs.org/en/" target="_blank" rel="external">nodejs官网</a>上下载pkg文件安装。node和npm的执行文件都在/usr/local/bin/里。 /usr/local/lib/node_modules/npm/usr/local/lib/node_modules/n/bin 则是实际上存放npm和n的地方。n是一个用来管理nodejs版本的包。但不用这个,下面会用到nvm,更方便一些。</p>
<h2 id="卸载node"><a href="#卸载node" class="headerlink" title="卸载node"></a>卸载node</h2><p>MAC下卸载软件很多直接删除安装包就行了。但node的一些文件在系统目录和用户目录里都有,你得找到全部,逐一删除。比较麻烦。这也是推荐用nvm的一个原因。你可以用nvm卸载node。nvm自身的删除也比较简单,nvm及它安装的node都在用户目录下的.nvm文件夹,删除,升级都很方便。</p>
<p>终端：</p>
<p><code>lsbom -f -l -s -pf /var/db/receipts/org.nodejs.pkg.bom | while read f; do  sudo rm /usr/local/${f}; done</code><br>会删除一部分</p>
<p><code>sudo rm -rf /usr/local/lib/node /usr/local/lib/node_modules /var/db/receipts/org.nodejs.*</code><br>又会删除一部分</p>
<p>再执行</p>
<p><code>sudo rm -rf ~/.npm</code></p>
<p><code>sudo rm -rf ~/.node-gyp</code></p>
<p><code>sudo rm -rf /usr/local/include/node</code></p>
<p>主要集中在<code>/usr/local/</code>及username/liuhongyu/目录，也即用户目录和系统目录<br>比如/usr/local/bin下的n可执行文件。在这些文件夹中把与node有关的删除就行了。</p>
<p>还有就是在<code>username/.bash_profile</code>中删除环境变量。</p>
<h2 id="nvm安装"><a href="#nvm安装" class="headerlink" title="nvm安装"></a>nvm安装</h2><p>另一种方式是采用nvm安装。nvm和nodejs等是独立的。这样方便管理一些。并且用nvm安装node可以多个版本共存,切换起来也比较方便。在<a href="https://github.com/creationix/nvm" target="_blank" rel="external">nvm官方github</a>上有详细的安装过程。在MAC上也可以使用homebrew来安装,便于nvm自身的版本管理。不过我当初还是按照github上的说明安装的。</p>
<p>MAC下nvm比较方便,但并不支持windows,不过nvm的作者推荐了windows上用<code>nvm-windows</code>。是由另外一个人完成的。</p>
<p>当你<code>curl https://raw.githubusercontent.com/creationix/nvm/v0.17.2/install.sh | bash</code>的时候<br>会自动增加环境变量到.bash_profile中,也就是说不需要你手动添加环境变量了。</p>
<h3 id="nvm的卸载"><a href="#nvm的卸载" class="headerlink" title="nvm的卸载"></a>nvm的卸载</h3><p>直接删除就行了。终端命令:<code>rm -rf ~/.nvm</code></p>
<h3 id="nvm安装node-js"><a href="#nvm安装node-js" class="headerlink" title="nvm安装node.js"></a>nvm安装node.js</h3><p>终端输入<code>nvm</code>,会弹出一些文字说明,会告诉你一些nvm命令的使用方法。</p>
<p>如<code>nvm install  v0.12.0</code></p>
<p>node被安装到了<code>username/.nvm/versions/node/v0.12.0</code>里面<br>并且也有npm:<br><code>username/.nvm/versions/node/v0.12.0/lib/node_modules/npm</code></p>
<h3 id="nvm卸载node"><a href="#nvm卸载node" class="headerlink" title="nvm卸载node"></a>nvm卸载node</h3><p><code>nvm uninstall &lt;version&gt;</code></p>
<h3 id="nvm使用node"><a href="#nvm使用node" class="headerlink" title="nvm使用node"></a>nvm使用node</h3><p><code>nvm current</code></p>
<p><code>nvm use 0.1.20</code></p>
<h3 id="nvm自身升级"><a href="#nvm自身升级" class="headerlink" title="nvm自身升级"></a>nvm自身升级</h3><p>nvm的自身升级对node没有影响。但降级对node有影响</p>
<h2 id="npm包管理器"><a href="#npm包管理器" class="headerlink" title="npm包管理器"></a>npm包管理器</h2><p>node的包都是由npm管理的。所以我们用nvm管理node(包括nvm自身),用npm管理node的包。npm安装包有2种方式:全局安装和本地安装。</p>
<h3 id="全局安装"><a href="#全局安装" class="headerlink" title="全局安装"></a>全局安装</h3><p>安装敲命令的时候加上<code>-g</code>,比如以安装<code>hexo</code>为例:</p>
<p><code>sudo npm install hexo -g</code></p>
<p>这样安装的包就会像npm一样被安装在了<code>username/.nvm/versions/node/v0.12.0/lib/node_modules/</code>里面。然后被安装的包如’hexo’就可以全局使用了。</p>
<h3 id="本地安装"><a href="#本地安装" class="headerlink" title="本地安装"></a>本地安装</h3><p>终端下切换到你的工程目录。</p>
<p><code>npm install packagename</code></p>
<p>这样就会在你的工程目录中生成node_modules文件夹,包会安装在这里。</p>
<p>当然最好是:</p>
<p><code>npm init</code></p>
<p>这样会生成一个<code>package.json</code>,下次安装包的时候加上<code>-- save</code>后缀,就可以在<code>package.json</code>中保存包的信息。这样就比较方便在别处安装。比如你在github上clone别人的开源项目,一般是没有node_modules包的。因为这个比加大,push上去也没有必要。一般会push <code>package.json</code>,你clone到<code>package.json</code>以后直接<code>npm install</code>,就会安装<code>package.json</code>里面的所有包,比较方便。</p>
<p>以express为例:</p>
<p><code>npm install express --save</code></p>
<p>这样express的信息就被记录在了<code>package.json</code>里,下次如果你要安装很多个包,就不需要一个一个安装了。直接<code>npm install</code>就行了。</p>
<h2 id="node使用"><a href="#node使用" class="headerlink" title="node使用"></a>node使用</h2><p>node的文档在<a href="https://nodejs.org/en/docs/" target="_blank" rel="external">node官网</a>上。可以先练习一下相关的API。但了解一下即可。具体有项目需求自取查阅,这样学的快一些。</p>
<h2 id="基于node的框架"><a href="#基于node的框架" class="headerlink" title="基于node的框架"></a>基于node的框架</h2><p>直接用node原生进行开发的项目应该是比较少的了。一般采用基于node的一些web框架如express和koa</p>
<h3 id="express"><a href="#express" class="headerlink" title="express"></a>express</h3><p><a href="http://expressjs.com/" target="_blank" rel="external">express官网</a></p>
<h3 id="koa"><a href="#koa" class="headerlink" title="koa"></a>koa</h3><p><a href="http://koajs.com/" target="_blank" rel="external">koa官网</a></p>
<h2 id="MEAN快速构建网站"><a href="#MEAN快速构建网站" class="headerlink" title="MEAN快速构建网站"></a>MEAN快速构建网站</h2><p><code>MEAN</code>:mongodb,express,angularjs,node</p>
<h2 id="2个现成的"><a href="#2个现成的" class="headerlink" title="2个现成的"></a>2个现成的</h2><p><a href="https://github.com/linnovate/mean" target="_blank" rel="external">linnovate/mean</a></p>
<p><a href="https://github.com/meanjs/mean" target="_blank" rel="external">meanjs/mean</a></p>
<h2 id="手工拼接"><a href="#手工拼接" class="headerlink" title="手工拼接"></a>手工拼接</h2><p>大多数情况下,并不用上面2个现成的项目。而是自己用MEAN各个部分进行开发。这有分为2部分:</p>
<h3 id="重前端"><a href="#重前端" class="headerlink" title="重前端"></a>重前端</h3><p>以angular为主。虽然还是用到了node等,但业务逻辑什么的大多数由类似<code>angular,react,vue</code>这样的前端框架来完成。当然还有mongodb,但项目中mongoose用的多。</p>
<h3 id="重后端"><a href="#重后端" class="headerlink" title="重后端"></a>重后端</h3><p>直接用node+express或node+koa就行了。不用前端框架。比如<a href="https://github.com/cnodejs/nodeclub" target="_blank" rel="external">cnode社区源码</a>就是直接用Node.js 和 MongoDB 开发的社区系统。也被很多人拿来做二次开发。在github上搜索cnode可以搜到很多。</p>
<h3 id="Restful-API"><a href="#Restful-API" class="headerlink" title="Restful API"></a>Restful API</h3><h1 id="打包构建工具"><a href="#打包构建工具" class="headerlink" title="打包构建工具"></a>打包构建工具</h1><p>不用这些工具,应用也能正常运行。但用了更好。就像嵌入式里用UCOS-II操作系统。也是这样。</p>
<h2 id="Grunt-vs-Gulp"><a href="#Grunt-vs-Gulp" class="headerlink" title="Grunt vs Gulp"></a>Grunt vs Gulp</h2><h2 id="Browserify-vs-Webpack"><a href="#Browserify-vs-Webpack" class="headerlink" title="Browserify vs Webpack"></a>Browserify vs Webpack</h2><h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><h2 id="AWS"><a href="#AWS" class="headerlink" title="AWS"></a>AWS</h2><h2 id="阿里云"><a href="#阿里云" class="headerlink" title="阿里云"></a>阿里云</h2><h2 id="leancloud"><a href="#leancloud" class="headerlink" title="leancloud"></a>leancloud</h2><h2 id="coding"><a href="#coding" class="headerlink" title="coding"></a>coding</h2><h1 id="移动端"><a href="#移动端" class="headerlink" title="移动端"></a>移动端</h1><p>不得不说JS全栈的好处。能干的活非常多。对于讲究开发效率的互联网产品来说,这是非常重要的。JS能够这么流行的一个重要原因在于:强大的开源社区。人多了,解决方案自然也多了。JS刚出道的时候还只能写一些网页脚本,现在已经无处不在。</p>
<h2 id="reactjs"><a href="#reactjs" class="headerlink" title="reactjs"></a>reactjs</h2><h2 id="ionic"><a href="#ionic" class="headerlink" title="ionic"></a>ionic</h2><h1 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h1><h2 id="Electron"><a href="#Electron" class="headerlink" title="Electron"></a>Electron</h2><h1 id="嵌入式"><a href="#嵌入式" class="headerlink" title="嵌入式"></a>嵌入式</h1><h2 id="Tessel"><a href="#Tessel" class="headerlink" title="Tessel"></a>Tessel</h2><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="https://cnodejs.org/getstart" target="_blank" rel="external">cnode社区新手入门</a></p>
<p>《node与express开发》</p>
<p>《Nodejs实战》</p>
<p>《Nodejs实战》第2季</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/20/C语言小结3/" itemprop="url">
                  C语言小结3
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2016-06-20T18:48:26+08:00" content="2016-06-20">
              2016-06-20
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Technology/" itemprop="url" rel="index">
                    <span itemprop="name">Technology</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <h1 id="函数-数组-指针-字符串-结构体-共用体"><a href="#函数-数组-指针-字符串-结构体-共用体" class="headerlink" title="函数,数组,指针,字符串,结构体,共用体"></a>函数,数组,指针,字符串,结构体,共用体</h1><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>指针变量在使用之前必须进行初始化:</p>
<p>int num = 100;</p>
<p>int *p;</p>
<p>printf(“%d”,*p); //error,未初始化</p>
<p>指针未初始化可能会出现意外的后果。系统中有一些垃圾数据。未初始化时系统可能赋值给指针p一个垃圾数据当作地址。这个地址可能不该访问。</p>
<p>下面这样赋值会把100当成地址:</p>
<p>p = num;</p>
<p>printf(“%d”,*p); //可能会报错。因为地址为100的内存区域可能是系统的。这样可能会造成非法访问。</p>
<p>像上面这样赋值还会有类型问题。左边是int *类型,右边是int类型</p>
<p>p = \&num;  //这样赋值以后p就指向了num</p>
<p>一般在声明的时候就初始化:</p>
<p>int *p = \&num;</p>
<h3 id="取地址运算符-amp-，-间接运算符"><a href="#取地址运算符-amp-，-间接运算符" class="headerlink" title="取地址运算符&amp;， 间接运算符*"></a>取地址运算符&amp;， 间接运算符*</h3><p>\&amp;运算符:  取地址运算符，\&amp;m即是变量m在内存中的实际地址。</p>
<p>*运算符： 指针运算符 (通常称为间接引用运算符),它返回其操作数 (即一个指针)所指向的对象的值.这种方式访问变量称为间接访问。直接访问是直接使用变量名来访问。</p>
<p>打印指针,地址格式符:%p , %x</p>
<p>%x:   按照十六进制打印，无意义的0就不打印</p>
<p>%p:   显示地址的位数，32位，8个十六进制，2^4=16,32位<br>      显示地址的位数，64位，16个十六进制位，64个二进制位</p>
<h3 id="指向指针的指针-二级指针"><a href="#指向指针的指针-二级指针" class="headerlink" title="指向指针的指针,二级指针"></a>指向指针的指针,二级指针</h3><p>通过**声明一个二级指针</p>
<p>int num;</p>
<p>int *a = \&num;</p>
<p>int **b = \&a;</p>
<p>指针作为函数形参:</p>
<p>函数形式参数，除了数组以外，传递的任何数据，变量，都会新建一个变量接收传入的变量的值。不影响原来的变量，如果是一个数据，传递数据的地址（指针），如果是一个指针，传递指针的地址。</p>
<p><strong> 注: </strong> 声明的时候 int *p = \&num;  <em> 与 int在一起表示指针类型(int \</em>)。右边直接赋值为地址。</p>
<p>但声明后使用则不能 *p = \&num;  因为此时*p表示p指向的那个值。应该用 p = \&num;</p>
<p>所谓指针类型，指的是声明指针变量时位于变量名前的“类型*”，而所谓指针所指向的类型，指的是为指针初始化或赋值的变量类型。</p>
<p>不是同一类型的指针，不可以任意赋值。不同的数据类型，大小不一样（如果强制赋值的话，就会少读取或多读取，内存有很多垃圾0,1），解析方式不一样.</p>
<p>注:指针不同类型之间的赋值和数据不同类型之间的赋值还有所不同。后者只是数据有溢出或截短，但前者可能找到另外一个指针去了，指向的就不再是以前的那个数据了。</p>
<p>同类型指针的赋值.这是最常见的一种情况，如所示，pN1和pN2是两个相同类型的指针，执行“pN2=pN1;”这样一个赋值操作后，pN1和pN2指向同样的地址，也就是说，两个指针指向同一个内存单元，对<em>pN2的任何改动都会影响</em>pN1的值，反之亦然。</p>
<h3 id="指针的类型和指针所指向的类型"><a href="#指针的类型和指针所指向的类型" class="headerlink" title="指针的类型和指针所指向的类型"></a>指针的类型和指针所指向的类型</h3><p>指针除了地址以外还有类型，类型决定了指向的数据大小，决定了数据的解析方式。指针的类型必须要与指针指向的类型一致。</p>
<p>指向内存字节数大于指针类型占据的字节数</p>
<p>指向内存字节数小于指针类型占据的字节数</p>
<h3 id="指针变量的值"><a href="#指针变量的值" class="headerlink" title="指针变量的值"></a>指针变量的值</h3><p>指针变量的值是指针本身存储的数值，这个值将被编译器当作一个地址，而不是<br>一个一般的数值。在32位程序里，所有类型的指针的值都是一个32位整数，因为32位程序里内存地址长度都为32位。</p>
<p>指针所指向的内存区就是从指针的值所代表的那个内存地址开始，长度为sizeof(指针所指向的类型)的一片内存区。</p>
<p>指针存储的是地址，地址是首地址，从哪里开始，从哪里结束，由类型决定，类型决定长度，决定如何解析。</p>
<h3 id="指针的运算"><a href="#指针的运算" class="headerlink" title="指针的运算"></a>指针的运算</h3><p>int a = 5;</p>
<p>int *p = a;</p>
<p>*p = 3;</p>
<p>把a的值5作为地址 0x00000005赋值给*p是发生访问冲突。整数与指针最好不要直接运算。</p>
<h3 id="指向数组的指针"><a href="#指向数组的指针" class="headerlink" title="指向数组的指针"></a>指向数组的指针</h3><p>指向数组的指针被编译器解析为数组的首地址</p>
<p>数组的遍历:</p>
<p>通过下标循环进行遍历</p>
<p>a[i]和*(a + i)等价</p>
<p>通过dll注入的方式修改另一个进程的数据</p>
<p>int a[3] = {1,2,3};</p>
<p>int *p = a;</p>
<p>printf(“%d,%x,%x”,*p,a,&amp;p);</p>
<p>通过定义并初始化二级指针p(下面给*<em>p赋的值是读到的上面\</em>p的地址&amp;p),使其改变另一个程序的指针p的指向，从而改变它的值。</p>
<p>_declspec(dllexport) void go()<br>{</p>
<p>int *<em>p = (int *</em>)0x1bf734;   //注意左右两边的类型要匹配</p>
<p>*p = (int *)(0x1bf740 + 36);  //注意左右两边的类型要匹配</p>
<p>}</p>
<h3 id="指针的算术运算"><a href="#指针的算术运算" class="headerlink" title="指针的算术运算"></a>指针的算术运算</h3><p>指针++就是按照指针类型的大小，前进一个类型(不是一个字节)的大小，如int,前进四个字节。</p>
<p>指针++就是按照指针类型的大小，前进一个类型(不是一个字节)的大小，int,前进四个字节。</p>
<p>指针++  就是 指针每次向前移动sizeof(指针类型)个字节。</p>
<p>通过指针循环(以前是下标循环)的方式初始化数组a的每一个元素（从头到尾扫描数组）:</p>
<p>int a[5];</p>
<p>int i = 0;</p>
<p>for(int *p = a;p &lt; a + 5;p++) //在数组内部用p++才有意义,移动的是sizeof(*p)个字节</p>
<p>{</p>
<p>  *p = i++;</p>
<p>}</p>
<p>注:i(下标循环)和p(指针循环)的效果是一样的。注意指针p++只能用于数组内部</p>
<p>指针加上2,在数组内部等价于向后移动两个元素的大小,指针减去3，等价于数组内部，向前移动3个元素(和p++是一致的)的大小</p>
<p>求指针的具体地址</p>
<p>double   *p=0x300400;<br>p=p+2   ; //p=0x300416=p+2<em>sizeof(double)<br>p=p-5;    //p=0x300416-sizeof(double)\</em>5=0x300376</p>
<h3 id="指针之间的比较"><a href="#指针之间的比较" class="headerlink" title="指针之间的比较"></a>指针之间的比较</h3><p>对两个毫无关联的指针比较大小是没有意义的，因为指针只代表了“位置”这么一个信息， 但是， 如果两个指针所指向的元素位于同一个数组（或同一块动态申请的内存中）， 指针的大小比较反映了元素在数组中的先后关系。</p>
<p>注：指针往往和数组联系在一起。要么就像游戏外挂那样，直接赋值为一个地址。</p>
<h3 id="指针运算"><a href="#指针运算" class="headerlink" title="指针运算"></a>指针运算</h3><p>*p++ 与<em>(p++)一样，相当于a[i++]<br>\</em>(++p)，相当于a[++i]<br>(*p)++ 表示p所指向的元素值加1，而非指针值加1</p>
<p>num[i]与*（num+i）等价    &amp;num[i]等价于  num+i<br>num是第一个元素的首地址，指向int 类型<br>每次指针相加，相加指针指向的类型的大小</p>
<h3 id="指向元素的指针与指向数组的指针"><a href="#指向元素的指针与指向数组的指针" class="headerlink" title="指向元素的指针与指向数组的指针"></a>指向元素的指针与指向数组的指针</h3><p>若有定义int(*p)[3];则定义了一个名为p的指针变量，表示p是一个指针变量，它可以指向每行有三个整数（即int型）元素的二维数组.</p>
<p>p指针每一次加1就相当于把p中存的地址加6（前提是int类型占2个字节，在VC中是占4个字节）。</p>
<p>例子：</p>
<p>int a[3][3];</p>
<p>int(*p)[3];</p>
<p>p = a; //p=a的意思是把数组a的首地址存放到p中那么p[1]就是a[1][0]的地址，p[1][0]就等于a[1][0]，而p[1][2]就等于a[1][2].</p>
<p>a通常表示一维数组首地址,&amp;a通常表示二维数组首地址。但在二维数组中a和&amp;a的值是相等的。</p>
<p><img src="http://7xpy7l.com1.z0.glb.clouddn.com/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88.png" alt=""></p>
<p>注:赋值的时候要注意类型匹配。</p>
<p><img src="http://7xpy7l.com1.z0.glb.clouddn.com/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88-1.png" alt=""></p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/20/C语言小结2/" itemprop="url">
                  C语言小结2
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2016-06-20T18:48:19+08:00" content="2016-06-20">
              2016-06-20
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Technology/" itemprop="url" rel="index">
                    <span itemprop="name">Technology</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <h1 id="语言逻辑流程"><a href="#语言逻辑流程" class="headerlink" title="语言逻辑流程"></a>语言逻辑流程</h1><h2 id="C语言语句类型"><a href="#C语言语句类型" class="headerlink" title="C语言语句类型:"></a>C语言语句类型:</h2><p><img src="http://7xpy7l.com1.z0.glb.clouddn.com/C%E8%AF%AD%E8%A8%80%E8%AF%AD%E5%8F%A5%E7%B1%BB%E5%9E%8B.png" alt=""></p>
<h2 id="结构化程序设计的3种控制结构"><a href="#结构化程序设计的3种控制结构" class="headerlink" title="结构化程序设计的3种控制结构"></a>结构化程序设计的3种控制结构</h2><h3 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h3><h3 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h3><h4 id="if-else"><a href="#if-else" class="headerlink" title="if else"></a>if else</h4><p>if else 嵌套</p>
<p>If—else语句同时使用，需要匹配出现，否则出现“没有匹配if的非法else”错误</p>
<h4 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h4><p>switch(表达式)</p>
<p> {</p>
<pre><code>case 常量表达式1:语句1

case 常量表达式2:语句2

……

case 常量表达式n:语句n

default:语句n+1
</code></pre><p>  }</p>
<p>switch语句中的“表达式”和case后面的“常量表达式”的结果值的类型应该一致。其类型可以是除实型以外的任何类型（如整型、字符型、枚举类型）。每一个case后的常量表达式的值必须互不相同。执行完一个case后面的语句后，流程控制到下一个case继续执行。因此，多个case可共用一组语句。</p>
<p>switch语句中可以不含default分支；default分支并不限定在最后，几个case分支也没有顺序区别，但必须做适当处理，否则会影响执行结果。当default语句省略时，表示“缺省情况下什么也不做”。某些编译器可能会对default语句的缺失给出警告，从防错意义上说，即使什么也不做，最好也把default语句写上，采用下述形式：<br>default：<br>；/<em>（空语句。不要忘记分号）</em>/<br>当default语句不在switch结构的最后时，不要忘记使用break。</p>
<p>break为跳出去执行switch后面的语句。终止switch语句的执行。为了执行完某个分支后跳出switch结构，应在其后加上break语句。如果不加break则会顺序执行下一个case语句。</p>
<p>int num;</p>
<p>switch(num)<br>{</p>
<p>  case 3:</p>
<p>  //</p>
<p>  case 2:</p>
<p>  printf(“大于2”);</p>
<p>  break;</p>
<p>  case 1:</p>
<p>  printf(“为1”);</p>
<p>  break;</p>
<p>  default://default可以不在最后</p>
<p>  break;//最后一个default可以省略。也是可以跳出switch的。</p>
<p>}</p>
<p>关闭_CRT_SECURE_NO_WARNINGS警告:(不然像scanf()这类函数都不能用)</p>
<p>在项目-&gt;属性-&gt;C/C++-&gt;预处理器-&gt;预处理器定中添加<br>  _CRT_SECURE_NO_WARNINGS 这个预定义。</p>
<p>下图中default语句在中间,如果不写break,输入5,则除了会打印”输入不合法”,还会打印”输入为2”.即使没有default语句,最后一个case 0不加break,也不会有错误结果。但一般都要加上。</p>
<p><img src="http://7xpy7l.com1.z0.glb.clouddn.com/C%E8%AF%AD%E8%A8%80switch%E8%AF%AD%E5%8F%A5.PNG" alt=""></p>
<h4 id="if与Switch语句进行比较"><a href="#if与Switch语句进行比较" class="headerlink" title="if与Switch语句进行比较"></a>if与Switch语句进行比较</h4><p>switch结构只进行相等与否的判断，而if…else…结构还可以进行大于小于等范围上的判断。</p>
<p>此外，switch无法处理浮点数，只进行整数的判断，</p>
<p>而且，case标签值必须是常量，如果涉及到浮点数和变量的判断，应当使用if…else…结构。应当从可读性和程序效率多方面综合考虑，适当搭配两种结构，方能写出高质量的代码。</p>
<h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3><h4 id="C语言中的三种循环语句"><a href="#C语言中的三种循环语句" class="headerlink" title="C语言中的三种循环语句"></a>C语言中的三种循环语句</h4><p>while 语句（当型）</p>
<p>do-while 语句（直到型）</p>
<p>for 语句（当型）</p>
<h4 id="循环体中的辅助控制语句"><a href="#循环体中的辅助控制语句" class="headerlink" title="循环体中的辅助控制语句"></a>循环体中的辅助控制语句</h4><h5 id="break-语句"><a href="#break-语句" class="headerlink" title="break 语句"></a>break 语句</h5><p>用在switch语句中使流程跳出switch结构，继续执行switch语句后面的语句。<br>用在循环体内，迫使所在循环立即终止(跳出当前循环体)，继续执行循环体后面的第一条语句。</p>
<p>break语句不能用于循环语句和switch语句之外的任何其他语句。</p>
<h5 id="continue-语句"><a href="#continue-语句" class="headerlink" title="continue 语句"></a>continue 语句</h5><p>结束本次循环(跳过循环体中尚未执行的语句)，接着进行是否执行下一次循环的判定。</p>
<h4 id="continue和break的区别"><a href="#continue和break的区别" class="headerlink" title="continue和break的区别"></a>continue和break的区别</h4><p>continue只结束本次循环，而非终止整个循环。</p>
<p>break则是结束所在循环，不再进行条件判断。</p>
<h5 id="goto-语句"><a href="#goto-语句" class="headerlink" title="goto 语句"></a>goto 语句</h5>
            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/20/C语言小结/" itemprop="url">
                  C语言小结
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2016-06-20T18:48:08+08:00" content="2016-06-20">
              2016-06-20
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Technology/" itemprop="url" rel="index">
                    <span itemprop="name">Technology</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <h1 id="IDE-helloword"><a href="#IDE-helloword" class="headerlink" title="IDE,helloword"></a>IDE,helloword</h1><p>visual studio 2013</p>
<h1 id="数据类型-运算符-表达式"><a href="#数据类型-运算符-表达式" class="headerlink" title="数据类型,运算符,表达式"></a>数据类型,运算符,表达式</h1><h2 id="内存中的位，字节，字"><a href="#内存中的位，字节，字" class="headerlink" title="内存中的位，字节，字"></a>内存中的位，字节，字</h2><p>计算机中的内存是以位为最小存储单位的。通过对内存进行组织，可以引用特定的位集合。把计算机的内存起始位编号为1，每隔8位编号增1，也就是以字节为单位，每隔一个字节编号向上加一，可以对计算机所有内存进行编号。</p>
<p><img src="http://7xpy7l.com1.z0.glb.clouddn.com/C%E8%AF%AD%E8%A8%80C%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png" alt=""></p>
<p>不同数据类型占据的空间不同。char一般占1个byte,short一般占2个,int在16位机器上占2个,在32位机器上占4个,double占8个</p>
<h2 id="原码反码补码"><a href="#原码反码补码" class="headerlink" title="原码反码补码"></a>原码反码补码</h2><p>正数：原码、反码、补码相同</p>
<p>负数：最高位为1，其余位为原码取反，再对整个数加1。也就是反码加1（逆操作就是反码减1再取反）</p>
<p>一般只提原码，补码，反码只是作为过渡。</p>
<p>在原码，补码的转换中，符号位是不变的。不论正负。负数的其它位进行取反操作。</p>
<p>在计算机系统中,数值一律用补码来表示。</p>
<h2 id="有符号数与无符号数"><a href="#有符号数与无符号数" class="headerlink" title="有符号数与无符号数"></a>有符号数与无符号数</h2><p>以int类型为例。16位机器上,默认(signed) int为有符号数。数值范围是-32767——32767.无符号数是unsigned int,范围是0——65535。</p>
<p>例子:</p>
<p>unsigned char x= - 0x10;</p>
<p>printf(“%x\n”,x);//输出f0</p>
<p>signed char x= - 0x10;</p>
<p>printf(“%x\n”,x);//输出fffffff0</p>
<p>Printf(“%x”,&amp;x)   //按照十六进制形式打印x的地址</p>
<p>%d : 以十进制形式输出数据<br>%o : 以八进制形式输出数据<br>%x : 以十六进制形式输出数据<br>%u : 以十进制形式输出unsigned型数据</p>
<p><img src="http://7xpy7l.com1.z0.glb.clouddn.com/C%E8%AF%AD%E8%A8%80%E6%A0%BC%E5%BC%8F%E5%AD%97%E7%AC%A6-1.png" alt=""></p>
<p><img src="http://7xpy7l.com1.z0.glb.clouddn.com/C%E8%AF%AD%E8%A8%80%E6%A0%BC%E5%BC%8F%E5%AD%97%E7%AC%A6-2.png" alt=""></p>
<p>unsigned char x= - 0x10;</p>
<p>原码 ‭0001 0000‬   unsigned char符号位应该是0,也就是不存储符号位</p>
<p>反码 1110 1111   但仍然是负数,如果是正数的话,反码和原码是一样的</p>
<p>补码 1111 0000   这一个首位的1不是符号位,是数据位,和原码不存储符号位是一致的,如果首位存储符号位的话,就无法存储数据位了。这就相当于一个正数0x10了。总之,符号位丢了。</p>
<p>Printf(“%x”,&amp;x)的时候会把这个unsigned char以无符号(unsigned)的十六进制形式输出。也就是 0000 0000 1111 0000,也就是f0了</p>
<p>signed char x= - 0x10;</p>
<p>原码: ‭1001 0000   1是符号位,不是数据位</p>
<p>反码: 1110 1111   反码和符号位没关系,是数据位取反</p>
<p>补码: 1111 0000   首位1是符号位</p>
<p>Printf(“%x”,&amp;x)的时候会把这个unsigned char以无符号(unsigned)的十六进制形式输出。就变成 0000  0000  1111 0000,又是00f0了。显然与结果不符。</p>
<p>关键是现在signed char的首位1是个符号位。转化为unsigned int的话,应该不能这样转化。</p>
<p>原码: 0000 0000 0001 0000<br>反码: 1111 1111 1110 1111<br>补码: 1111 1111 1111 0000</p>
<p><strong> 小结 </strong></p>
<p>符号位是不参与数据位的取反,加1操作的。</p>
<p>正数的原码,反码,补码一样,负数才有这些操作。关键在符号位和数据位不要处理混了。还有尽管上面用ussigned char存储-1,首位为0,但仍然是负数,它的补码还是取反的。不像正数,补码是它本身。但首位变成了数据位,也参与取反运算。</p>
<p>上面看出:unsigned char 转换为unsigned int直接加00就行了。但signed char转unsigned int还要从原码开始计算,不能随意丢弃符号位,不能随意把符号位变为数据位。</p>
<p>以补码形式存储。以原码形式读取?还是要区分正负。有无符号位。</p>
<p>计算机没有数据类型的概念。并不认识unsigned和signed</p>
<p>再用-1尝试。</p>
<p>unsigned char x= - 1;</p>
<p>printf(“%x\n”,x);//输出ff</p>
<p>signed char x= - 1;</p>
<p>printf(“%x\n”,x);//输出fffffff</p>
<p>以signed int形式打印。</p>
<p>unsigned char x= - 1;</p>
<p>printf(“%d\n”,x);//输出</p>
<p>signed char x= - 1;</p>
<p>printf(“%d\n”,x);//输出</p>
<p>unsigned char x= - 1;</p>
<p>原码 0000 0001</p>
<p>反码 1111 1110</p>
<p>补码 1111 1111   //首位是数据位。可以直接转换为signed int</p>
<p>0000 0000 1111 1111 // 255  。现在首位为0,并非为1,直接转换来的.现在为正数,原码,补码,反码相等</p>
<p>signed char x= - 1;</p>
<p>原码 1000 0001</p>
<p>反码 1111 1110</p>
<p>补码 1111 1111 //首位是符号位,不可以直接转换为signed int,从源码开始重新计算</p>
<p>原码 1000 0000 0000 0001</p>
<p>反码 1111 1111 1111 1110</p>
<p>补码 1111 1111 1111 1111 //首位是符号位</p>
<p>难道是 -32767 ？实际输出为-1。也就是虽然以补码形式存储,但还是以原码形式输出。</p>
<p>8进制：octal</p>
<p>10进制：decimal</p>
<p>16进制：hex</p>
<h2 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h2><p>转义字符列表:</p>
<p><img src="http://7xpy7l.com1.z0.glb.clouddn.com/C%E8%AF%AD%E8%A8%80%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6%E5%88%97%E8%A1%A8.png" alt=""></p>
<h2 id="字符常量与变量"><a href="#字符常量与变量" class="headerlink" title="字符常量与变量"></a>字符常量与变量</h2><p>字符常量：</p>
<p>定义:用单引号括起来的单个普通字符或转义字符.</p>
<p>字符常量的值：该字符的ASCII码值</p>
<p>转义字符:反斜线后面跟一个字符或一个代码值表示</p>
<p>ASCII码表:</p>
<p><img src="http://7xpy7l.com1.z0.glb.clouddn.com/C%E8%AF%AD%E8%A8%80ascii%E7%A0%81%E8%A1%A8.png" alt=""></p>
<p>字符串常量：用双引号括起来的字符序列，每个字符串尾自动加个‘\0’作为字符串结束标志。</p>
<p>例子:四种方式都是打印h</p>
<p>十进制104，八进制150，十六进制68</p>
<p>在上面转义字符表格中有说明</p>
<p>\ddd  1-3位八进制数所代表的任意字符<br>\xhh  1-2位十六进制数代表的任意字符   </p>
<p>putchar(‘h’);</p>
<p>putchar(104);</p>
<p>putchar(‘\150’); //开始以为是putchar(‘\d150’); 但实际上不需要加d</p>
<p>putchar(‘\x68’);</p>
<p>字符’1’和整数1是不同的概念：</p>
<p>字符’1’只是代表一个形状为’1’的符号，在需要时按原样输出，在内存中以ASCII码形式存储，占1个字节。</p>
<p>整数1是以整数存储方式(二进制补码方式)存储的，占2个或4个字节。</p>
<p>如何存储和如何表示的是不一样的。存储都以补码形式存储。</p>
<p><strong> 例子: </strong></p>
<p>int a = 1;</p>
<p>Printf(“%d,%c”,a,a);  //%d是输出a数值本身。%c是输出ASCII码值为a的字符</p>
<p>char ch = ‘\0’;</p>
<p>Printf(“%d,%c”,ch,ch);  //%d是求它的编号(ASCII码编号), %c是求ASCII码字符本身</p>
<p>字符型变量在内存中占一个字节，由于存储的是字符的二进制ASCII码(补码?)，与整型数据存储方式类似，字符型数据和整型数据可以相互运算。</p>
<p><strong> 注意： </strong> 字符串常量不允许赋值给字符型变量，C语言也没有专门的字符串变量。要在内存中存取字符串，只能使用数组或指针。</p>
<h3 id="ASCII码特例"><a href="#ASCII码特例" class="headerlink" title="ASCII码特例"></a>ASCII码特例</h3><p>关于ASCII码表:</p>
<p>48是数字0，</p>
<p>65是A，</p>
<p>97是a，</p>
<p>0是’\0’  也就是NULL，注意如果打印这个值，是什么也不输出，而非输出0</p>
<p>32是空格字符</p>
<h2 id="类型自动转换"><a href="#类型自动转换" class="headerlink" title="类型自动转换"></a>类型自动转换</h2><h3 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h3><p>整型、实型和字符型数据之间可以混合运算。例如：</p>
<p>10 + ’a’ + 1.5 - 8765.1234 * ’b’</p>
<p>不同数据类型之间运算会进行自动类型转换，规则如下：</p>
<p><img src="http://7xpy7l.com1.z0.glb.clouddn.com/C%E8%AF%AD%E8%A8%80%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.png" alt=""></p>
<p>常常打印的几个值: 所占的字节长度，地址，数值大小</p>
<p>低字节向高字节转换，极限范围小的向极限范围大的转换。  数据较大会从有符号数向无符号数转换</p>
<p>赋值的时候，会自动将右边表达式转换成左边变量类型</p>
<h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><p><img src="http://7xpy7l.com1.z0.glb.clouddn.com/C%E8%AF%AD%E8%A8%80%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.png" alt=""></p>
<h3 id="高类型向低类型转化时可能发生精度损失"><a href="#高类型向低类型转化时可能发生精度损失" class="headerlink" title="高类型向低类型转化时可能发生精度损失"></a>高类型向低类型转化时可能发生精度损失</h3><p>unsigned short a = 256;</p>
<p>char b = a;</p>
<p>printf(“%d”,b);//结果不是256,b只截取了a的低8位数据</p>
<h3 id="当把占字节较小的数据赋值给占字节较大的数据时，可能出现以下两种情况"><a href="#当把占字节较小的数据赋值给占字节较大的数据时，可能出现以下两种情况" class="headerlink" title="当把占字节较小的数据赋值给占字节较大的数据时，可能出现以下两种情况"></a>当把占字节较小的数据赋值给占字节较大的数据时，可能出现以下两种情况</h3><p>第1种情况，当字节较大数是无符号数时，转换时新扩充的位被填充成0</p>
<p>char b = 10;</p>
<p>unsigned short a = b;</p>
<p>printf(“%u”,a);</p>
<p>这样赋值后，变量a中输出的值是10</p>
<p>第2种情况，当字节较大数是有符号数时，转换时新扩充的位被填充成符号位</p>
<p>char b = 255;</p>
<p>short a = b;</p>
<p>printf(“%d”,a); //-1    </p>
<p>b: 1111 1111  //char应该是有符号数。是存储不了255的,溢出了。这里可能进行了类型转换。转换成了无符号数。但1还是符号位?  signed确实会向unsigned转换。</p>
<p>a: 1111 1111 1111 1111 //补码,表示-1</p>
<p>CHAR_MAX  有符号char最大值</p>
<p>CHAR_MIN  有符号char最小值</p>
<h1 id="位运算文件函数高级指针高级内存高级映射-内存四区生存期作用域"><a href="#位运算文件函数高级指针高级内存高级映射-内存四区生存期作用域" class="headerlink" title="位运算文件函数高级指针高级内存高级映射_内存四区生存期作用域"></a>位运算<em>文件</em>函数高级<em>指针高级</em>内存高级映射_内存四区生存期作用域</h1><h1 id="编译选项-数据结构-链表-栈-队列-实战"><a href="#编译选项-数据结构-链表-栈-队列-实战" class="headerlink" title="编译选项,(数据结构)链表,栈,队列,实战"></a>编译选项,(数据结构)链表,栈,队列,实战</h1><h2 id="references"><a href="#references" class="headerlink" title="references:"></a>references:</h2>
            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/17/javascript小结/" itemprop="url">
                  javascript小结
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2016-06-17T06:45:49+08:00" content="2016-06-17">
              2016-06-17
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Technology/" itemprop="url" rel="index">
                    <span itemprop="name">Technology</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <h1 id="html"><a href="#html" class="headerlink" title="html"></a>html</h1><p>学前预热课程里有这部分内容,但是没有PPT资料,是自己截图的。</p>
<p>有一个能够在Browser上运行的模板html。如果是nodejs的话,就是一个能够正常运行的express模板。</p>
<h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><p>P36</p>
<h2 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h2><p>P39</p>
<h2 id="event"><a href="#event" class="headerlink" title="event"></a>event</h2><p>P40</p>
<h3 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h3><h3 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h3><h2 id="cookie与session"><a href="#cookie与session" class="headerlink" title="cookie与session"></a>cookie与session</h2><p>P53</p>
<h1 id="css"><a href="#css" class="headerlink" title="css"></a>css</h1><p>样式有优先级，id的优先级大于class，所以有时候你改变class样式可能会没用。</p>
<p>Css需要放在<style>标签，类似的JS需要<script>标签</p>
<style type=”text/css”>

</style>

</p><p>S中的style只能获取行间样式，所以后来才会去用currentStyle和getComputedStyle</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><h3 id="《javascript权威指南》"><a href="#《javascript权威指南》" class="headerlink" title="《javascript权威指南》"></a>《javascript权威指南》</h3><h3 id="W3Cshhool-en-注意版本CSS3-CSS2"><a href="#W3Cshhool-en-注意版本CSS3-CSS2" class="headerlink" title="W3Cshhool-en   注意版本CSS3,CSS2"></a><a href="http://www.w3schools.com/" target="_blank" rel="external">W3Cshhool-en</a>   注意版本CSS3,CSS2</h3><h3 id="W3Cshhool-ch"><a href="#W3Cshhool-ch" class="headerlink" title="W3Cshhool-ch"></a><a href="http://www.w3school.com.cn/" target="_blank" rel="external">W3Cshhool-ch</a></h3>
            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/22/使用Android-Studio进行Android开发/" itemprop="url">
                  使用Android Studio进行Android开发
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2016-05-22T18:54:29+08:00" content="2016-05-22">
              2016-05-22
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Technology/" itemprop="url" rel="index">
                    <span itemprop="name">Technology</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <h1 id="开源项目第一步"><a href="#开源项目第一步" class="headerlink" title="开源项目第一步"></a>开源项目第一步</h1><h2 id="readme"><a href="#readme" class="headerlink" title="readme"></a>readme</h2><h2 id="工程目录-模块文件"><a href="#工程目录-模块文件" class="headerlink" title="工程目录,模块文件"></a>工程目录,模块文件</h2><h2 id="函数调用链"><a href="#函数调用链" class="headerlink" title="函数调用链"></a>函数调用链</h2><h2 id="使用版本控制工具查看各个release版本"><a href="#使用版本控制工具查看各个release版本" class="headerlink" title="使用版本控制工具查看各个release版本"></a>使用版本控制工具查看各个release版本</h2>
            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/22/Android-Studio使用指南/" itemprop="url">
                  Android Studio使用指南
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2016-05-22T18:43:24+08:00" content="2016-05-22">
              2016-05-22
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Technology/" itemprop="url" rel="index">
                    <span itemprop="name">Technology</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <h1 id="Android-Studio下载安装"><a href="#Android-Studio下载安装" class="headerlink" title="Android Studio下载安装"></a>Android Studio下载安装</h1><h2 id="SDK"><a href="#SDK" class="headerlink" title="SDK"></a>SDK</h2><p>SDK的安装目录可以和Android Studio的安装目录分开。</p>
<h2 id="DNK"><a href="#DNK" class="headerlink" title="DNK"></a>DNK</h2><p>NDK也是如此。</p>
<h2 id="ant"><a href="#ant" class="headerlink" title="ant"></a>ant</h2><p>可以通过<code>brew install ant</code> 来安装.<br>在<code>android/SDK/android-sdk-macosx/tools/ant</code>中也有相关的一些文件</p>
<h2 id="gradle"><a href="#gradle" class="headerlink" title="gradle"></a>gradle</h2><h2 id="adb"><a href="#adb" class="headerlink" title="adb"></a>adb</h2><p>在<a href="https://wiki.cyanogenmod.org/w/Doc:_adb_intro/zh-cn" target="_blank" rel="external">文档：adb简介</a>中有它的介绍。adb在SDK的platform-tools目录。用Alfred搜索<code>platform-tools</code>，就可以找到它在<br><code>/Users/liuhongyu/Desktop/liu/workspace/mobile/android/intellij_idea/android/SDK/android-sdk-macosx/platform-tools/adb</code>中找到。</p>
<p><img src="http://7xpy7l.com1.z0.glb.clouddn.com/Android48.png" alt=""></p>
<p>把环境变量添加到~/.bash_profile中,然后就可以在终端使用了:</p>
<p><code>if [ -d &quot;&lt;path-to-sdk&gt;/platform-tools&quot; ] ; then
  export PATH=&quot;&lt;path-to-sdk&gt;/platform-tools:$PATH&quot;
fi</code></p>
<h1 id="AVD"><a href="#AVD" class="headerlink" title="AVD"></a>AVD</h1><h2 id="google自带的AVD"><a href="#google自带的AVD" class="headerlink" title="google自带的AVD"></a>google自带的AVD</h2><h2 id="Genymotion"><a href="#Genymotion" class="headerlink" title="Genymotion"></a>Genymotion</h2><p>在setting中输入plugin进行搜索:</p>
<p>在<a href="https://www.genymotion.com/download/" target="_blank" rel="external">Genymotion官网</a>下载Genymotion。</p>
<p><img src="http://7xpy7l.com1.z0.glb.clouddn.com/Android35.png" alt=""></p>
<p><img src="http://7xpy7l.com1.z0.glb.clouddn.com/Android35.1.png" alt=""></p>
<p>安装好之后重启就能在右上角看见插件了:</p>
<p><img src="http://7xpy7l.com1.z0.glb.clouddn.com/Android36-1.png" alt=""></p>
<p>打开Genymotion，需要登录帐号才能够使用虚拟设备:</p>
<p><img src="http://7xpy7l.com1.z0.glb.clouddn.com/Android38.png" alt=""></p>
<p><img src="http://7xpy7l.com1.z0.glb.clouddn.com/Android39.png" alt=""></p>
<p><img src="http://7xpy7l.com1.z0.glb.clouddn.com/Android40.png" alt=""></p>
<p><img src="http://7xpy7l.com1.z0.glb.clouddn.com/Android41.png" alt=""></p>
<p>到底下载到了哪里？在settings中可以找到：<br>/Users/liuhongyu/.Genymobile/Genymotion/deployed/Custom\ Phone\ -\ 6.0.0\ -\ API\ 23\ -\ 768x1280</p>
<p>还有就是下载了VitualBox貌似并不需要怎么配置，甚至不需要打开(默认打开了?)就能够使用Genymotion的虚拟设备了</p>
<p><img src="http://7xpy7l.com1.z0.glb.clouddn.com/Android41.1.png" alt=""></p>
<p>点击start，就弹出来虚拟机了</p>
<p><img src="http://7xpy7l.com1.z0.glb.clouddn.com/Android42.png" alt=""></p>
<p><img src="http://7xpy7l.com1.z0.glb.clouddn.com/Android43.png" alt=""></p>
<p>运行helloword<br>需要先在右上角启动genymotion的虚拟机，然后再点击运行:</p>
<p><img src="http://7xpy7l.com1.z0.glb.clouddn.com/Android44.png" alt=""></p>
<p><img src="http://7xpy7l.com1.z0.glb.clouddn.com/Android45.png" alt=""></p>
<p><img src="http://7xpy7l.com1.z0.glb.clouddn.com/Android36.1.png" alt=""></p>
<p><img src="http://7xpy7l.com1.z0.glb.clouddn.com/Android46.png" alt=""></p>
<p>在<a href="https://www.virtualbox.org/wiki/Downloads" target="_blank" rel="external">VitualBox官网</a>下载安装VitualBox。一路next安装就可以了。不需要特别的设置就可以使用Genymotion。</p>
<h3 id="VitualBox"><a href="#VitualBox" class="headerlink" title="VitualBox"></a>VitualBox</h3><h1 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h1><h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><h1 id="使用gradle进行构建"><a href="#使用gradle进行构建" class="headerlink" title="使用gradle进行构建"></a>使用gradle进行构建</h1><h2 id="build-gradle分析"><a href="#build-gradle分析" class="headerlink" title="build.gradle分析"></a>build.gradle分析</h2><p>以新建的helloworld为例进行分析。这个工程。会有2个build.gradle: project下的build.gradle,module下的build.gradle。</p>
<h3 id="project下的build-gradle"><a href="#project下的build-gradle" class="headerlink" title="project下的build.gradle"></a>project下的build.gradle</h3><p><code>buildscript {</code></p>
<pre><code>repositories {
    jcenter()  //远程仓库,以前使用maven
}
dependencies {
    classpath &apos;com.android.tools.build:gradle:2.1.0&apos;
</code></pre><p>//gradle插件。要换成自己的版本。从安装目录里看到   com.android.tools.build是包名</p>
<pre><code>    // NOTE: Do not place your application dependencies here; they belong
    // in the individual module build.gradle files
}
</code></pre><p>}</p>
<p>allprojects {</p>
<pre><code>repositories {
    jcenter()
}
</code></pre><p>}</p>
<p>task clean(type: Delete) {</p>
<pre><code>delete rootProject.buildDir
</code></pre><p>}</p>
<p>project下的build.gradle里面会配置一个gradle插件的目录。这个插件在本地的:<code>/Applications/Android\ Studio.app/Contents/gradle/m2repository/com/android/tools/build/gradle</code>中</p>
<p><img src="http://7xpy7l.com1.z0.glb.clouddn.com/Android47.png" alt=""></p>
<p>关于gradle还有一个目录:<code>/Users/liuhongyu/.gradle/wrapper/dists/gradle-2.8-all</code>。这个是本地的,上面是从远程仓库中下载的。</p>
<p>在<code>preferences</code>中搜索<code>gradle</code>:<br><img src="http://7xpy7l.com1.z0.glb.clouddn.com/Android49.png" alt=""></p>
<p>在<code>project structure——project</code>中也可以看到:</p>
<p><img src="http://7xpy7l.com1.z0.glb.clouddn.com/Android50.png" alt=""></p>
<p>在项目的<code>HelloWorld/gradle/wrapper/gradle-wrapper.properties</code>文件中也是有的:</p>
<p><img src="http://7xpy7l.com1.z0.glb.clouddn.com/Android51.png" alt=""></p>
<p><strong>注:有时候AS会提醒你升级gradle,因为项目可能是别人的,使用到了不同版本的gradle,下载之后不仅需要指定相应的gradle目录,还要修改相关配置文件</strong></p>
<p><strong>注:每次修改完build.gradle文件之后需要重新sync project with gradle files(以gradle方式构建项目),或者make project(以ant方式构建项目)</strong></p>
<p><strong>注</strong> project下的build.gradle中不能有如下配置:</p>
<p>compileSdkVersion 23</p>
<p>buildToolsVersion “23.0.3”</p>
<p>SDK版本的配置应该在module的build.gradle文件中</p>
<h3 id="module下的build-gradle"><a href="#module下的build-gradle" class="headerlink" title="module下的build.gradle"></a>module下的build.gradle</h3><p>apply plugin: ‘com.android.application’  //应用程序</p>
<p>//android自身的配置</p>
<p>android {//点击project structure可以查看</p>
<pre><code>compileSdkVersion 23
buildToolsVersion &quot;23.0.3&quot;

defaultConfig {
    applicationId &quot;com.example.liuhongyu.helloworld&quot;//应用程序包名
    minSdkVersion 8
    targetSdkVersion 23
    versionCode 1
    versionName &quot;1.0&quot;
}
buildTypes {
    release {
        minifyEnabled false  //设置混淆
        proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos; //proguard-android.txt指定混淆文件,系统指定的规则
    }
}
</code></pre><p>}</p>
<p>//依赖的配置</p>
<p>dependencies {</p>
<pre><code>compile fileTree(`dir: &apos;libs&apos;, include: [&apos;*.jar&apos;]`) // jar包和库都会在这里进行编译
testCompile &apos;junit:junit:4.12&apos;
compile &apos;com.android.support:appcompat-v7:23.3.0&apos;
compile &apos;com.android.support:design:23.3.0&apos;
</code></pre><p>}</p>
<p><strong>注:最上面的compileSdkVersion 23和buildToolsVersion “23.0.3”在project structure中可以查看得到</strong></p>
<p><img src="http://7xpy7l.com1.z0.glb.clouddn.com/Android52.png" alt=""></p>
<h2 id="jcenter中央仓库及依赖-dependency-管理"><a href="#jcenter中央仓库及依赖-dependency-管理" class="headerlink" title="jcenter中央仓库及依赖(dependency)管理"></a>jcenter中央仓库及依赖(dependency)管理</h2><p>比如上面的dependencies中<code>compile &#39;com.android.support:design:23.3.0&#39;</code><br>如果在jcenter中央仓库下载，就会被解析为<br><a href="http://jcenter.bintray.com/com/android/support/design/23.3.0,把逗号变成分号" target="_blank" rel="external">http://jcenter.bintray.com/com/android/support/design/23.3.0,把逗号变成分号</a>.</p>
<h3 id="jcenter和mavenCentral"><a href="#jcenter和mavenCentral" class="headerlink" title="jcenter和mavenCentral"></a>jcenter和mavenCentral</h3><h3 id="gradle是如何从仓库获取library"><a href="#gradle是如何从仓库获取library" class="headerlink" title="gradle是如何从仓库获取library"></a>gradle是如何从仓库获取library</h3><h3 id="依赖管理-导入jar或依赖"><a href="#依赖管理-导入jar或依赖" class="headerlink" title="依赖管理(导入jar或依赖)"></a>依赖管理(导入jar或依赖)</h3><h2 id="导入外部项目并进行构建"><a href="#导入外部项目并进行构建" class="headerlink" title="导入外部项目并进行构建"></a>导入外部项目并进行构建</h2><h3 id="导入Eclipse工程"><a href="#导入Eclipse工程" class="headerlink" title="导入Eclipse工程"></a>导入Eclipse工程</h3><p>导入外部项目(eclipse项目)的时候,有2种构建方式:ant构建方式(与用eclipse一样了)和gradle构建方式。</p>
<h4 id="方式一：导入后以gradle构建-含依赖库"><a href="#方式一：导入后以gradle构建-含依赖库" class="headerlink" title="方式一：导入后以gradle构建(含依赖库)"></a>方式一：导入后以gradle构建(含依赖库)</h4><p>假设要导入的项目<code>PhoneSafe</code>目录结构如下,有一个依赖的外部库<code>XUtilsLibrary</code>:</p>
<p>直接导入上面的<code>PhoneSafe</code>项目:</p>
<p><img src="http://7xpy7l.com1.z0.glb.clouddn.com/Android54.png" alt=""></p>
<p><img src="http://7xpy7l.com1.z0.glb.clouddn.com/Android55.png" alt=""></p>
<p><img src="http://7xpy7l.com1.z0.glb.clouddn.com/Android56.png" alt=""></p>
<p><img src="http://7xpy7l.com1.z0.glb.clouddn.com/Android57.png" alt=""></p>
<p><img src="http://7xpy7l.com1.z0.glb.clouddn.com/Android58.png" alt=""></p>
<p><img src="http://7xpy7l.com1.z0.glb.clouddn.com/Android59.png" alt=""></p>
<p>错误原因:项目的<code>project.properties</code>文件中,已经设置了外部库,把这一行删除再重新导入一次就行了:</p>
<p><img src="http://7xpy7l.com1.z0.glb.clouddn.com/Android60.png" alt=""></p>
<p><img src="http://7xpy7l.com1.z0.glb.clouddn.com/Android61.png" alt=""></p>
<p>将XUtilsLibrary以外部module方式导入进来:</p>
<p><img src="http://7xpy7l.com1.z0.glb.clouddn.com/Android62.png" alt=""></p>
<p><img src="http://7xpy7l.com1.z0.glb.clouddn.com/Android63.png" alt=""></p>
<p><img src="http://7xpy7l.com1.z0.glb.clouddn.com/Android64.png" alt=""></p>
<p><img src="http://7xpy7l.com1.z0.glb.clouddn.com/Android65.png" alt=""></p>
<p>把<code>XUtilsLibrary</code>设置为<code>PhoneSafe</code> APP的依赖,在<code>project structure</code>中</p>
<p><img src="http://7xpy7l.com1.z0.glb.clouddn.com/Android66.png" alt=""></p>
<p><img src="http://7xpy7l.com1.z0.glb.clouddn.com/Android67.png" alt=""></p>
<p><img src="http://7xpy7l.com1.z0.glb.clouddn.com/Android68.png" alt=""></p>
<p><img src="http://7xpy7l.com1.z0.glb.clouddn.com/Android69.png" alt=""></p>
<p><strong>注:会报一些错误,大多是2个build.gradle的配置问题</strong></p>
<h4 id="方式二：导入后以Ant构建-含依赖库"><a href="#方式二：导入后以Ant构建-含依赖库" class="headerlink" title="方式二：导入后以Ant构建(含依赖库)"></a>方式二：导入后以Ant构建(含依赖库)</h4><p>把<code>PhoneSafe</code>和外部库<code>XUtilsLibrary</code>放在外层的<code>PhoneSafe</code>目录下导入:</p>
<p><img src="http://7xpy7l.com1.z0.glb.clouddn.com/Android53.png" alt=""></p>
<p><img src="http://7xpy7l.com1.z0.glb.clouddn.com/Android55.png" alt=""></p>
<p><img src="http://7xpy7l.com1.z0.glb.clouddn.com/Android70.png" alt=""></p>
<p><img src="http://7xpy7l.com1.z0.glb.clouddn.com/Android71.png" alt=""></p>
<p><img src="http://7xpy7l.com1.z0.glb.clouddn.com/Android72.png" alt=""></p>
<p><img src="http://7xpy7l.com1.z0.glb.clouddn.com/Android73.png" alt=""></p>
<p>bin目录要去勾选:</p>
<p><img src="http://7xpy7l.com1.z0.glb.clouddn.com/Android74.png" alt=""></p>
<p><img src="http://7xpy7l.com1.z0.glb.clouddn.com/Android75.png" alt=""></p>
<p><img src="http://7xpy7l.com1.z0.glb.clouddn.com/Android76.png" alt=""></p>
<p><img src="http://7xpy7l.com1.z0.glb.clouddn.com/Android77.png" alt=""></p>
<p><img src="http://7xpy7l.com1.z0.glb.clouddn.com/Android78.png" alt=""></p>
<p><img src="http://7xpy7l.com1.z0.glb.clouddn.com/Android79.png" alt=""></p>
<p><img src="http://7xpy7l.com1.z0.glb.clouddn.com/Android80.png" alt=""></p>
<p><img src="http://7xpy7l.com1.z0.glb.clouddn.com/Android81.png" alt=""></p>
<p><img src="http://7xpy7l.com1.z0.glb.clouddn.com/Android82.png" alt=""></p>
<p><strong>2者之间的区别</strong></p>
<p>(1)导入时是否有外部目录</p>
<p>(2)导入时gradle构建方式会出现gradle构建的对话框</p>
<p>(3)由于(2)的缘故。gradle构建方式会出现build.gradle,ant构建方式则没有。</p>
<p>(4)修改了配置文件的同步:一个用<code>make project</code>,一个用<code>sync project with gradle files</code></p>
<h1 id="AS调试"><a href="#AS调试" class="headerlink" title="AS调试"></a>AS调试</h1><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><h1 id="签名混淆打包"><a href="#签名混淆打包" class="headerlink" title="签名混淆打包"></a>签名混淆打包</h1><h2 id="多渠道打包"><a href="#多渠道打包" class="headerlink" title="多渠道打包"></a>多渠道打包</h2><h1 id="AS版本控制-VCS"><a href="#AS版本控制-VCS" class="headerlink" title="AS版本控制(VCS)"></a>AS版本控制(VCS)</h1><h2 id="SVN-默认"><a href="#SVN-默认" class="headerlink" title="SVN(默认)"></a>SVN(默认)</h2><p>用AS新建好项目后,在项目的<code>.idea/vcs.xml</code>文件中有VCS相关配置。默认使用SVN,AS也默认安装了SVN?和相应的插件?(<strong>这个默认安装的subversion貌似是mac安装的,不是AS安装的</strong>)</p>
<p><img src="http://7xpy7l.com1.z0.glb.clouddn.com/Android83.png" alt=""></p>
<p>在<a href="https://www.jetbrains.com/help/idea/15.0/authenticating-to-subversion.html" target="_blank" rel="external">Authenticating to Subversion</a>提到了<br><code>/Users/liuhongyu/.subversion</code>这个目录,应该是默认安装了的。</p>
<p><img src="http://7xpy7l.com1.z0.glb.clouddn.com/Android87.png" alt=""></p>
<p>在项目中也有相应的SVN目录:</p>
<p><img src="http://7xpy7l.com1.z0.glb.clouddn.com/Android95.png" alt=""></p>
<p>点击上传按钮:</p>
<p><img src="http://7xpy7l.com1.z0.glb.clouddn.com/Android84.png" alt=""></p>
<p>点击下载按钮:</p>
<p><img src="http://7xpy7l.com1.z0.glb.clouddn.com/Android85.png" alt=""></p>
<p>会卡在认证这一步:</p>
<p><img src="http://7xpy7l.com1.z0.glb.clouddn.com/Android86.png" alt=""></p>
<p>点击<code>cancel</code>之后会报错</p>
<p><img src="http://7xpy7l.com1.z0.glb.clouddn.com/Android88.png" alt=""></p>
<p>在preference-VCS中有SVN相关配置:</p>
<p><img src="http://7xpy7l.com1.z0.glb.clouddn.com/Android89.png" alt=""></p>
<p>google <code>android studio authentication realm svn</code><br><a href="http://stackoverflow.com/questions/21323421/android-studio-cant-authenticate-with-svn" target="_blank" rel="external">Android Studio can’t authenticate with SVN</a>中提到了把上面2项去勾选就可以了:</p>
<p><img src="http://7xpy7l.com1.z0.glb.clouddn.com/Android90.png" alt=""></p>
<p>还是会报错:<code>android studio commit failed with error: svn E175002:unknown host</code></p>
<p><img src="http://7xpy7l.com1.z0.glb.clouddn.com/Android91.png" alt=""></p>
<p><a href="http://blog.csdn.net/zhouzme/article/details/22790395" target="_blank" rel="external">【AndroidStudio】关于SVN的相关配置简介</a></p>
<p>终端能用svn说明可以使用:</p>
<p><img src="http://7xpy7l.com1.z0.glb.clouddn.com/Android101.png" alt=""></p>
<p>勾选下面2项:</p>
<p><img src="http://7xpy7l.com1.z0.glb.clouddn.com/Android102.png" alt=""></p>
<p><code>brew install subversion</code>安装subversion,把<code>export PATH=/usr/local/Cellar/subversion/1.8.13/bin</code>添加到<code>.bash_profile</code>,还是会包这个错误</p>
<p><a href="http://stackoverflow.com/questions/14509251/svn-error-e175002" target="_blank" rel="external">SVN Error E175002</a>  </p>
<p>在系统中搜索svn或apache但搜索不到。用spotlight搜索也是。用Alfred搜索发现apache在自己安装的MAMP中。但这个并非系统默认安装的。可能是Alfred搜索不到隐藏文件?</p>
<p>修改Apache下的<code>httpd.conf</code>,把<code>Directory</code>字段下改为<code>allow from all</code>或<code>require all granted</code>,还是会报错</p>
<p>打开MAMP,还是会报错。</p>
<p>但用brew安装新的subversion会引起新的问题:终端中node等很多命令不能用了,如下图:</p>
<p><img src="http://7xpy7l.com1.z0.glb.clouddn.com/Android104.png" alt=""></p>
<p><img src="http://7xpy7l.com1.z0.glb.clouddn.com/Android105.png" alt=""></p>
<p>解决:把<code>export PATH=/usr/local/Cellar/subversion/1.8.13/bin</code>从<code>.bash_profile</code>中删除,重启终端就可以了。看来mac默认安装的一些软件还不能乱改。</p>
<h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><p>首先用<code>brew insatll git</code>安装git</p>
<p>然后在AS中安装git插件。默认安装了的</p>
<p>在AS中配置git插件：File-&gt;Setting-&gt;Version Control-&gt;Git, 然后选择你本地的Git安装路径:</p>
<p><img src="http://7xpy7l.com1.z0.glb.clouddn.com/Android92.png" alt=""></p>
<p>将项目初始化git项目(git init)，操作如下：VCS-&gt;Enable Control Integration-&gt;Select “Git”.（当然也可以使用git命令，自行选择）</p>
<p>这个选项自己的项目没有。</p>
<p><a href="https://www.jetbrains.com/help/idea/2016.1/enable-version-control-integration-dialog.html" target="_blank" rel="external">Enable Version Control Integration Dialog</a>中提示只有在项目没有使用任何Version Control System的时候才会出现。</p>
<p><strong>注:没有界面让你选择版本控制工具,但可以在<code>.idea/vcs.xml</code>文件中配置</strong></p>
<p><a href="http://www.cnblogs.com/lao-liang/p/5019549.html" target="_blank" rel="external">Android Studio配置Git及Git文件状态说明</a></p>
<p>将现有项目创建为本地git仓库。在工具栏依次选择VCS-&gt;Import into Version Control-&gt;Create Git Repository</p>
<p><img src="http://7xpy7l.com1.z0.glb.clouddn.com/Android93.png" alt=""></p>
<p><img src="http://7xpy7l.com1.z0.glb.clouddn.com/Android94.png" alt=""></p>
<p>不久之后项目的<code>.idea/vcs.xml</code>文件就改为git了:</p>
<p><img src="http://7xpy7l.com1.z0.glb.clouddn.com/Android96.png" alt=""></p>
<p><img src="http://7xpy7l.com1.z0.glb.clouddn.com/Android97.png" alt=""></p>
<p>在<code>PhoneSafe/PhoneSafe/src/cn/itcast/phonesafe/.git</code>中就多了<code>.git</code>文件夹</p>
<p>在配置界面其实可以看到所有的版本控制工具:</p>
<p><img src="http://7xpy7l.com1.z0.glb.clouddn.com/Android98.png" alt=""></p>
<p>可以添加:</p>
<p><img src="http://7xpy7l.com1.z0.glb.clouddn.com/Android99.png" alt=""></p>
<p>也可以选中一个进行编辑:</p>
<p><img src="http://7xpy7l.com1.z0.glb.clouddn.com/Android100.png" alt=""></p>
<p>在项目的<code>.idea/vcs.xml</code>文件中把版本控制工具再修改为svn:</p>
<p><img src="http://7xpy7l.com1.z0.glb.clouddn.com/Android103.png" alt=""></p>
<h3 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h3><h2 id="references"><a href="#references" class="headerlink" title="references:"></a>references:</h2><p><a href="http://ask.android-studio.org/?/article/23" target="_blank" rel="external">Android Studio 常用功能介绍</a></p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    

  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



        </div>

        


        

      </div>

      
        
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="/images/default_avatar.jpg" alt="lhy" itemprop="image"/>
          <p class="site-author-name" itemprop="name">lhy</p>
        </div>
        <p class="site-description motion-element" itemprop="description">Science technology and culture</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">22</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="/categories">
              <span class="site-state-item-count">2</span>
              <span class="site-state-item-name">分类</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">10</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


      
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="icon-next-heart fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lhy</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  

  
    
    

  


  

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.2"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.2"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
<script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

<script type="text/javascript" src="/js/motion.js?v=0.4.5.2" id="motion.global"></script>


  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  

  <script type="text/javascript" src="/js/bootstrap.js"></script>

  
  

  
  
<a href="https://github.com/lhyhfut"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/52760788cde945287fbb584134c4cbc2bc36f904/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f77686974655f6666666666662e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_white_ffffff.png"></a>
</body>
</html>
